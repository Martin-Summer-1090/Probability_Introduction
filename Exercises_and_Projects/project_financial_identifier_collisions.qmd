---
title: "Project: Financial Identifier Collisions Solutions"
format: html
---

## Project: Financial Identifier Collisions

In this project, we explore the likelihood of "collisions" in financial transaction identifiers. By simulating transaction identifiers and analyzing the probability of collisions, we can understand the challenges of designing secure financial systems.

---

### Exercise 1: Simulate Transaction Identifiers

#### Task
Write a function to simulate transaction identifiers, where each identifier is randomly chosen from a pool of size $M$.

#### Solution
```{r}
# Function to simulate transaction identifiers
simulate_identifiers <- function(n, M) {
  sample(1:M, n, replace = TRUE)
}

# Example: Simulate 1000 identifiers from a pool of size 1,000,000
set.seed(123)
identifiers <- simulate_identifiers(1000, 1e6)
identifiers
```

**Comments**:
- $n$ represents the number of transactions.
- $M$ represents the size of the identifier pool.

---

### Exercise 2: Check for Collisions

#### Task
Write a function to check if a collision occurred in a set of identifiers.

#### Solution
```{r}
# Function to check for collisions
has_collision <- function(identifiers) {
  any(duplicated(identifiers))
}

# Example: Check for collisions
has_collision(identifiers)
```

**Comments**:
- This function returns `TRUE` if there are duplicate identifiers, `FALSE` otherwise.

---

### Exercise 3: Estimate Collision Probability

#### Task
Simulate $n$ transactions multiple times and estimate the probability of at least one collision.

#### Solution
```{r}
# Function to estimate collision probability
collision_probability <- function(n, M, trials = 10000) {
  results <- replicate(trials, {
    identifiers <- simulate_identifiers(n, M)
    has_collision(identifiers)
  })
  mean(results)
}

# Example: Estimate collision probability for n = 1000, M = 1,000,000
start_time <- Sys.time()
prob <- collision_probability(1000, 1e6)
end_time <- Sys.time()
elapsed_time <- end_time - start_time
cat("Collision probability:", prob, "\n")
cat("Elapsed time:", elapsed_time, "\n")
```

**Comments**:
- Repeat the simulation for different values of $n$ and $M$ to analyze the relationship between transaction volume, pool size, and collision probability.

---

### Exercise 4: Visualize Collision Probability

#### Task
Plot the collision probability as a function of $n$ for different values of $M$.

#### Solution
```{r}
start_time <- Sys.time()
# Parameters
n_values <- seq(100, 10000, by = 100)
M_values <- c(1e6, 1e9)

# Compute probabilities
results <- lapply(M_values, function(M) sapply(n_values, collision_probability, M = M, trials = 100))

# Plot results
plot(n_values, results[[1]], type = "l", col = "blue", ylim = c(0, 1),
     xlab = "Number of Transactions (n)", ylab = "Collision Probability",
     main = "Collision Probability vs. Number of Transactions")
lines(n_values, results[[2]], col = "red")
legend("bottomright", legend = c("M = 1e6", "M = 1e9"), col = c("blue", "red"), lty = 1)
end_time <- Sys.time()
elapsed_time <- end_time - start_time
cat("Elapsed time:", elapsed_time, "\n")
```

**Comments**:
- Larger identifier pools $M$ significantly reduce the probability of collisions, even for high transaction volumes.

---

### Strategies to Cope with Big Computations

When brute-force simulations become too slow or resource-intensive, consider the following strategies:

#### 1. Simplify Parameters
Reduce the size of $M$ and the number of trials to make computations feasible, while maintaining the ability to observe general trends.
```{r}
# Reduced parameters
reduced_M_values <- c(1e5, 1e8)
reduced_n_values <- seq(100, 1000, 100)
reduced_trials <- 100

# Compute probabilities with reduced parameters
reduced_results <- lapply(reduced_M_values, function(M) sapply(reduced_n_values, collision_probability, M = M, trials = reduced_trials))
```

#### 2. Parallel Processing
Leverage multiple CPU cores to distribute computations and speed up the simulation process.
```{r}
# Parallel collision probability (example with parallel package)
library(parallel)
parallel_collision_probability <- function(n, M, trials = 100) {
  cl <- makeCluster(detectCores() - 1)
  clusterExport(cl, c("n", "M", "simulate_identifiers", "has_collision"))
  results <- parSapply(cl, 1:trials, function(x) {
    identifiers <- simulate_identifiers(n, M)
    has_collision(identifiers)
  })
  stopCluster(cl)
  mean(results)
}
```

#### 3. Analytical Approximation
Use mathematical models, such as the birthday problem formula, to estimate probabilities directly.
```{r}
# Analytical collision probability formula
analytical_collision_probability <- function(n, M) {
  1 - exp(-n^2 / (2 * M))
}

# Example: Analytical estimation
n_values <- seq(100, 1000, 100)
M <- 1e6
analytical_results <- sapply(n_values, analytical_collision_probability, M = M)

# Plot analytical results
plot(n_values, analytical_results, type = "l", col = "green", lwd = 2,
     xlab = "Number of Transactions (n)", ylab = "Collision Probability",
     main = "Analytical Approximation")
```

---

### Discussion

1. **Simplification of Parameters**: Useful for exploratory analysis but may lose precision.
2. **Parallel Processing**: Effective for large-scale simulations, though resource-dependent.
3. **Analytical Approximation**: Provides quick and accurate estimates when assumptions are valid.

These strategies demonstrate how to tackle computational challenges efficiently while exploring probabilistic models.
