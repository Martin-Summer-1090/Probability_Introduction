[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "An Introduction to Probability",
    "section": "",
    "text": "Preface",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "intro.html",
    "href": "intro.html",
    "title": "1  Introduction",
    "section": "",
    "text": "This is a book created from markdown and executable code.\nSee (knuth84?) for additional discussion of literate programming.\n\n1 + 1\n\n[1] 2",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "summary.html",
    "href": "summary.html",
    "title": "2  Summary",
    "section": "",
    "text": "In summary, this book has no content whatsoever.\n\n1 + 1\n\n[1] 2",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Summary</span>"
    ]
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "References",
    "section": "",
    "text": "Knuth, Donald E. 1984. “Literate Programming.” Comput.\nJ. 27 (2): 97–111. https://doi.org/10.1093/comjnl/27.2.97.",
    "crumbs": [
      "References"
    ]
  },
  {
    "objectID": "index.html#what-are-these-lecture-notes-about",
    "href": "index.html#what-are-these-lecture-notes-about",
    "title": "An Introduction to Probability",
    "section": "What are these lecture notes about",
    "text": "What are these lecture notes about\nThese lecture notes support the course An Introduction to Probability - with Applications to Computational Finance using R. The course introduces essential probability concepts that every finance practitioner must understand. As probability is crucial for solving financial problems computationally, we will use computational finance as the context to develop these ideas. The focus will be hands-on learning, enabling you to understand and internalize concepts by applying them yourself.\nTo make abstract concepts like randomness, chance, and probability more accessible, we will leverage computational tools, primarily R, and visualizations. By actively engaging with these tools, you’ll not only deepen your understanding of probability but also enhance your ability to apply it to real-world finance problems.\n\n\n\n\n\n\nKey learning objectives\n\n\n\n\nUnderstand foundational probability concepts.\nApply probability principles to solve computational finance problems.\nGain hands-on experience using R for probability and finance applications.\nDevelop proficiency in interpreting and visualizing probabilistic data.\n\n\n\nBut how can we build abstract concepts such as probability, random phenomena and chance by our own hands? While probability is a mathematical theory, it gains practical value and an intuitive meaning in connection with real or conceptual experiments such as, the future change in a stock price index, the future value of a portfolio of securities, the chance that a creditor is not going to be able to pay back your loan.\nMany of these experiments we can nowadays simulate on the computer. We can can construct, build and simulate a huge variety of random phenomena. We can - for instance - implement models of random fluctuations of asset prices. We can model financial risks and contemplate possible future scenarios through simulation.\nThe arrival of the computer has been indeed a sea change for the mathematics of probability because it allows both reflecting about probability through theorems and proofs as well as by making use of computer simulation. We can approach our understanding of abstract concepts by building them with our own hands on the computer. This is the approach to teaching you probability in this course.\nLet me give you one example right away. Don’t worry if you do not understand precisely what the following snippet of code is doing. We will learn the syntax of the R language as we go along. This is just to demonstrate you what I explained in words before by a simple example highlighting simulation of random processes and visualization.\n\n\n\n\n\n\nAn R example for illustration\n\n\n\n\n# Simulate daily returns for a stock\n\nset.seed(123)  # Ensure reproducibility\nn &lt;- 100       # Number of days\ndaily_returns &lt;- rnorm(n, mean = 0.001, sd = 0.02)  # Normal distribution\n\n# Compute cumulative returns\nprice &lt;- cumprod(1 + daily_returns) * 100  # Starting price = 100\n\n# Visualize the stock price\nplot(price, type = \"l\", col = \"blue\", lwd = 2,\n     main = \"Simulated Stock Price\",\n     xlab = \"Days\", ylab = \"Price\")\n\n\n\n\n\n\n\n\n\n\nThis example highlights:\n\nHow randomness influences stock price movements\nR’s usefulness in simulations and visualization.\n\nIt is, however important to always keep in mind that the real world is different from the theory world as well as from the simulated world. The real world is both richer and more complex than both theory and simulation. It may contain features which need to be be taken into account for the explanation of phenomena which are absent in theory or in the simulation. We will try our best to develop your feeling for the difference, between theoretical concepts, simulations and applications as well as for the interdependence of these three areas.\nThere are many ways to build virtual objects and to run simulations to manipulate them. For this we will need a programming language. The language we choose for this course is R and the integrated development environment RStudio. This is one of the main languages used in data analysis, statistics and data science and is widely used in industry and academia. It will be our tool to do probability in this course.\nSince this course was being taught the first time new AI tools such as large language models (LLMs) like chatGPT, Claude or Gemini have been introduced. These new powerful tools create new opportunities for learning and deepening knowledge such as the concepts learned in this course. In this year I will show you throughout the course, how you can leverage AI tools like ChatGPT for deeper learning. I encourage you to use these tools to generate examples, explain concepts, and debug R code.",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "index.html#downloading-and-installing-r",
    "href": "index.html#downloading-and-installing-r",
    "title": "An Introduction to Probability",
    "section": "Downloading and installing R",
    "text": "Downloading and installing R\nSo lets start by downloading and installing R first. R is an open source project maintained by an international team of developers. The software is made available through a website called the comprehensive R archive network (http://cran.r-project.org).\nAt the top of this website, in a box named “Download and install R” you will find three links for downloading R. Choose the link that describes your operating system, Windows, Mac or Linux. These links will lead you to the necessary information you need to install a current version of R. The easiest install option is to install R from precompiled binaries. There is also the option to built R from source on all operating systems if you have the tools and the expertise to do so. R also comes both in a 32-bit and a 64-bit version. It does not make a substantial difference which version you use. 64-bit versions can handle larger files and data sets with fewer memory management problems.",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "index.html#downloading-and-installing-rstudio",
    "href": "index.html#downloading-and-installing-rstudio",
    "title": "An Introduction to Probability",
    "section": "Downloading and installing RStudio",
    "text": "Downloading and installing RStudio\nRStudio is an application that helps you write and develop R code. It makes using R much easier for you than using it in isolation. The interface of RStudio looks the same across all operating systems.\nYou can download RStudio for free from https://www.rstudio.com/products/rstudio/. Select the box RStudio Desktop and follow the download instructions. RStudio Desktop is free. Note that you need to have a version of R installed to use RStudio.\nIf you have successfully installed R and RStudio, we are ready to start.\nThroughout this course I will use R with RStudio and when I do code demonstrations I will use this environment. R can be used in many other ways of course. Some of you might be accustomed to work with Jupyter Notebooks. I will just mention here that with some minor tweaks R can be used with Jupyter notebooks as well. I will not go into the details here. Those of you who are interested in such a setup are encouraged to ask chatGPT:\n\n“Please give me a step by step instruction how to set up the system to use R through Jupyter notebooks instead of RStudio.”",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "index.html#prerequisites",
    "href": "index.html#prerequisites",
    "title": "An Introduction to Probability",
    "section": "Prerequisites",
    "text": "Prerequisites\nThis course is built as an intuitive and elementary introduction to the field. No knowledge of probability or R is assumed and all concepts are built from scratch. You should be able to study for this course by relying on the slides and these lecture notes only without having to consult a textbook or further literature.\nMany of you will have heard or studied probability at some stage in college or at university. I hope the course will appeal to the newcomers as well as to the experienced. While it should allow the first group to quickly learn some of the most important concepts and raise your curiosity and excitement about a field of knowledge which is both beautiful and immensely practical, I hope it will open a new perspective for the more experienced among you and thus help deepening your understanding of concepts you might already have heard elsewhere.\nThe lectures develop probability concepts and R concepts in parallel. This follows the idea underlying this course to develop your knowledge of probability concepts by building them on the computer yourself and play with them. In this way we hope to build your R skills more thoroughly because they appear in a natural context and that this context also reinforces your understanding of probability.",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "index.html#structure-of-the-notes",
    "href": "index.html#structure-of-the-notes",
    "title": "An Introduction to Probability",
    "section": "Structure of the Notes",
    "text": "Structure of the Notes\nThe notes are structured into five main chapters. The idea is to cover each main chapter topic in one of the five double units allocated to this course.\nEach of the main chapters or lectures are followed by a so called project. The projects are meant to be worked on by you in the assigned groups between the lectures and should help you to practice and to deepen what you have learned. We will discuss the project questions at the end of each lecture. We will also distribute a worked problem after you have worked on it yourself.\nWe begin the first lecture, lecture 1 by discussing some of the main basic probability fundamentals by putting them in their historical context where the first ideas appear of how you could measure something such elusive as chance at all. Surprisingly these first simple ideas are already very rich and lead us quite far into the field and its problems.\nIn this lecture we will also give a first panoramic run down of what you can do with R. In this lecture the first application will be a simple game of chance, the rolling of a dice. This is the only non directly finance related example discussed at length in this course but as we go along you will recognize that dice games and investment problems, for example, are not all that far apart really, at least with respect to their probabilistic structure and how you can model it.\nBut even the very basic ideas of probability and R enable us, already at this early stage, to take on a serious real world problem as well. In fact, we can already at this early stage study and understand problems of the chance of coincidences. This class of problems is at the heart of the science of constructing cryptographically safe finger prints, so called hash-functions, which are at the heart of crypto-currencies such as Bitcoin.\nThe first project will deal with a classical dice game, which you can also play at the casino, the game of craps. While a toy game, it has much parallels with investment problems and builds the first skills that will later help you in analyzing investment problems.\nLecture 2 will introduce the first basic ideas a bit more formally and also generalize them. In particular it explains the basic ideas of how probability and frequencies of chance events are related. We will discuss the power as well as the limits of these ideas for applied work in probability.\nIn this lecture we will explain in detail how you can use R to read, store and manipulate data. We also start working with stock market data and randomly fluctuating asset prices and discuss how we can deepen our understanding of them using probability and R.\nProject 2 will help you to train and practice your understanding of data manipulation in R by analyzing a real world supervisory data set from the European Banking Authority EBA. We will use a really cool empirical probability pattern on the empirical frequency of leading digits - Benford’s law - for checking whether the data could be trusted or do look fishy on purely probabilistic grounds.\nIn Lecture 3 we will learn about the key concept of conditional probability. This lecture contains lots of concepts but it is also of key importance for understanding many problems in Finance and the management of financial risks. We will explain how the misunderstanding or perhaps willful ignorance of the concept of dependence is at the root of the big financial crisis of 2007-2008. We will also learn, how updating your probability assessments in the light of new data is important for investment decisions.\nOn top of this directly practical considerations, we will also learn how this particular problem of updating probability assessments in the light of new information helps us close a conceptual gap in the pure frequency interpretations of probability.\nIn terms of R this lecture gives you a bit of a break in the sense that it applies what we have learned before and thereby reinforces what we have already learned. It will introduce some useful techniques and functions along the way.\nIn project 3 you will deepen your understanding of how probability updating works and how its sound understanding can make a real difference for the success of investment decisions.\nLecture 4 will introduce you more precisely to the key probabilistic model of random returns and other random phenomena in Finance: The concept of a random variable and the concepts of expected value, variance, standard deviation, covariance and correlation. We will discuss at length the modelling of random returns and learn about the basic workhorse model of asset price dynamics, the binomial lattice.\nThis discussion gives us also the appropriate context to discuss how to write programs in R and some of the principles and constructions that are most useful for this task.\nIn the project for lecture 4 you will learn about how you can apply the ideas of random variables and the binomial distribution to deepen your understanding of credit risk.\nThe final Lecture 5 discusses the concept of continuous random variables, which is very important for a large body of applied work. You will be introduced to the normal distribution and its power and limits for modelling random returns and financial risks.\nIn terms of R this lecture will provide a good context for discussing what matters when you want to make your R code fast and efficient.\nThe last project will then allow us to connect all the concepts of the five lectures with the project following lecture 4 to get a somewhat realistic and practically useful model for analyzing and managing credit risk.",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "index.html#acknowledgements",
    "href": "index.html#acknowledgements",
    "title": "An Introduction to Probability",
    "section": "Acknowledgements",
    "text": "Acknowledgements\nI would like to thank my friend and colleague Branko Urošević that he entrusted me to develop this course for his new and innovative program in computational finance.\nI am very grateful for the opportunity to make a contribution to this effort and for all the encouragement, support and advice I got from him for this project. Of course he bears no responsibility whatsoever for any shortcomings of these lecture notes.\nI would also like to sincerely thank the students of the bootcamp probability course of January 2022 who gave me feedback and studied from the lecture. They were a fantastic and enthusiastic cohort.",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "index.html#references",
    "href": "index.html#references",
    "title": "An Introduction to Probability",
    "section": "References",
    "text": "References\nWhen you teach such a fundamental field as probability theory and its applications in Finance you teach from a core knowledge that has been built by many pioneers, experts and other teachers in this area. In this sense nothing contained in this course is original work. The only contribution a teacher can make is the way how the material is presented and combined. In this sense these lecture notes are nothing but a collection of well known and time tested material as well as an experiment in yet one more, hopefully innovative exposition.\nBut even in this field I have copied and recycled a lot from the teaching materials and collective wisdom of other colleagues whose examples and problems I found particularly helpful. Without any claim to completeness let me briefly go through the sources I have relied on most strongly when developing this course.\nWith respect to probability theory two sources have influenced me most and I have followed their example extensively in this course: William Fellers “An introduction to probability theory and its applications volume 1.” which first appeared in 1957. (Feller (1968)). While really old by now it is still in my view one of the most outstanding reference with respect to exposition and clarity of explanation as well as an inspiring source of enthusiasm for the subject. I just would like to mention as an aside that Feller (born Vilibald Srećko Feller) was a Croatian emigrant to first Germany and then the US in the 1930ies. You might claim him as a citizen of Croatia, former Yugoslavia or even Austria, since when he was born in 1906, what is now Croatia was still a part of the Austrian-Hungarian empire.\nMy second most important source for this course in terms of probability was Karl Schmedder’s course “An intuitive introduction to probabiliy”, which Karl developed for the online platform Coursera. I consider this course an outstanding didactical achievement and masterpiece. If you find this lectures fun, I can only encourage you to also do the course on Coursera, when you find time. It is for a reason that Karl’s course is the mostly viewed Coursera course from Switzerand.1\n1 See https://www.coursera.org/learn/introductiontoprobabilityIn terms of R and R programming I have followed and copied a lot from Garett Grolemund’s excellent book “Hands on programming with R”.(Grolemund (2014)) I encourage you to study this book. From it I have not only learned about one of the most excellent explanations of R concepts but also the insight that these concepts are best explained within a very concrete and non trivial application context rather than in a patchy series of toy examples. The dice example in lecture 1 is directly from Garett’s book, the rest is adaptions and transfers to a Finance context. Garrett’s book has some really fun gambling applications as the context for using and explaining R concepts.\nWith respect to Finance and investments I have relied on the excellent book by David Luenberger, “Investment Science”. (Luenberger (2009)) If you can get a hold of this fantastic work, I can only encourage you to get one and have it on your shelf. It is a role model of clarity of exposition and has much more to offer than we can cover in this book.\nFinally with respect to the history and the interpretations of probability, I have learned the most form the excellent book “10 great ideas about chance”, by Persi Diaconis and Brian Skyrms. (Diaconis and Skyrms (2019)) If you find probability interesting or even fascinating I encourage you to read this book at some stage, if you find time. It is full of highly interesting philosophical, mathematical, historical and fun facts and ideas about this very rich subject.\nBut now, lets get straight down to the matter at hand.\n\n\n\n\nDiaconis, Persi, and Brian Skyrms. 2019. 10 Great Ideas about Chance. Princeton University Press.\n\n\nFeller, William. 1968. An Introduction to Probability Theory and Its Applications. 3rd ed. Vol. 1. Wiley.\n\n\nGrolemund, Garrett. 2014. Hands on Programming with R. O’Reilly. https://rstudio-education.github.io/hopr/.\n\n\nLuenberger, David. 2009. Investment Science. Oxford University Press.",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "index.html#leveraging-chatgpt-free-version",
    "href": "index.html#leveraging-chatgpt-free-version",
    "title": "An Introduction to Probability",
    "section": "Leveraging ChatGPT (Free Version)",
    "text": "Leveraging ChatGPT (Free Version)\n\nUsing an LLM to Enhance Your Learning\nThroughout this course, you’ll learn how to use ChatGPT to support your studies. As a free tool, it offers capabilities that can make learning probability more interactive and engaging. Here’s how you can leverage it:\n\nClarify Concepts:\nAsk ChatGPT to explain concepts in simple terms or elaborate on topics you find difficult:\n\n“Explain the concept of a probability distribution with an example.”\n\nGenerate Examples:\nUse it to create additional examples for practice:\n\n“Can you give me an example of a random variable and how it applies in finance?”\n\nDebug R Code:\nIf you encounter issues with your R code, paste the code and ask:\n\n“Why does this R code not run, and how can I fix it?”\n\nPractice Exercises:\nRequest custom exercises:\n\n“Create three exercises to practice calculating probabilities for dice rolls.”\n\nSimulate Interactive Discussions:\nSimulate discussions with ChatGPT to test your understanding:\n\n“I think the variance of a constant is zero. Am I correct? Explain why or why not.”\n\nLearn Best Practices in R:\nAsk for tips to improve your coding practices:\n\n“What are the best practices for writing clean and efficient R code?”\n\n\nImportant Note:\nWhile ChatGPT is a powerful learning tool, remember to verify the outputs, especially for complex calculations, and always critically evaluate its suggestions.",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "index.html#signing-up-for-chatgpt-free-version",
    "href": "index.html#signing-up-for-chatgpt-free-version",
    "title": "An Introduction to Probability",
    "section": "Signing up for ChatGPT (Free Version)",
    "text": "Signing up for ChatGPT (Free Version)\nTo access the free version of ChatGPT, follow these steps:\n\nGo to https://chat.openai.com in your web browser.\nClick on the “Creat a free account” button to create an account. You can sign up using an email address or your existing Google or Microsoft account.\nFollow the prompts to verify your email address and complete the registration process.\nOnce registered, log in to access ChatGPT. You can start using it immediately for your learning needs.\n\nUsing ChatGPT is free, but note that certain features or advanced versions (e.g., GPT-40) may require a paid subscription. The free version (GPT-3.5) is sufficient for all activities and examples provided in this course.",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "index.html#using-jupyter-notebooks-with-r",
    "href": "index.html#using-jupyter-notebooks-with-r",
    "title": "An Introduction to Probability",
    "section": "Using Jupyter Notebooks with R",
    "text": "Using Jupyter Notebooks with R\nIf you prefer working in Jupyter notebooks instead of RStudio, follow these steps to set up your system:\n\nInstall Jupyter Notebook:\nInstall Jupyter using Python’s pip package manager:\npip install notebook\nInstall R and the IRkernel:\nInstall R on your system, then install the IRkernel within R:\ninstall.packages(\"IRkernel\")\nIRkernel::installspec()\nStart Jupyter Notebook:\nLaunch Jupyter from your terminal:\njupyter notebook\nCreate a New R Notebook:\nIn Jupyter, click “New” and select “R” to start an R notebook.\nInstall R Packages in Jupyter:\nUse the usual R syntax to install packages:\ninstall.packages(\"ggplot2\")\nlibrary(ggplot2)\n\nJupyter provides a flexible, interactive environment for running R code, making it an excellent alternative to RStudio.\n\nWith these resources and tools, you are ready to dive into the fascinating world of probability and computational finance!",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "index.html#leveraging-the-possibilities-of-chatgpt",
    "href": "index.html#leveraging-the-possibilities-of-chatgpt",
    "title": "An Introduction to Probability",
    "section": "Leveraging the possibilities of ChatGPT",
    "text": "Leveraging the possibilities of ChatGPT\nIn these lectures I try to help you building experience how to integrate large language models or LLMs into your learning and study process as well as to support you in coding and programming. There are several such models currently on the market. For this course I will use openAI’s chatGPT as a tool. chatGPT is available in a free version and in an enhanced pay-version. For the purposes of this course the free version is sufficient.\n\nUsing an LLM to Enhance Your Learning\nThroughout this course, you’ll learn how to use ChatGPT to support your studies. As a free tool, it offers capabilities that can make learning probability more interactive and engaging. Here’s how you can leverage it:\n\nClarify Concepts:\nAsk ChatGPT to explain concepts in simple terms or elaborate on topics you find difficult:\n\n“Explain the concept of a probability distribution with an example.”\n\nGenerate Examples:\nUse it to create additional examples for practice:\n\n“Can you give me an example of a random variable and how it applies in finance?”\n\nDebug R Code:\nIf you encounter issues with your R code, paste the code and ask:\n\n“Why does this R code not run, and how can I fix it?”\n\nPractice Exercises:\nRequest custom exercises:\n\n“Create three exercises to practice calculating probabilities for dice rolls.”\n\nSimulate Interactive Discussions:\nSimulate discussions with ChatGPT to test your understanding:\n\n“I think the variance of a constant is zero. Am I correct? Explain why or why not.”\n\nLearn Best Practices in R:\nAsk for tips to improve your coding practices:\n\n“What are the best practices for writing clean and efficient R code?”\n\n\nImportant Note:\nWhile ChatGPT is a powerful learning tool, remember to verify the outputs, especially for complex calculations, and always critically evaluate its suggestions. One such tool you might consider for cross checking is Wolfram | Alpha, which you can find here: https://www.wolframalpha.com/ in a free version-",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "index.html#using-an-llm-to-enhance-your-learning",
    "href": "index.html#using-an-llm-to-enhance-your-learning",
    "title": "An Introduction to Probability",
    "section": "Using an LLM to Enhance Your Learning",
    "text": "Using an LLM to Enhance Your Learning\nIn these lectures I try to help you building experience how to integrate large language models or LLMs into your learning and study process as well as to support you in coding and programming. There are several such models currently on the market. For this course I will use openAI’s chatGPT as a tool. ChatGPT is available in a free version and in an enhanced pay-version. For the purposes of this course the free version is sufficient.\nThroughout this course, you’ll learn how to use ChatGPT to support your studies. As a free tool, it offers capabilities that can make learning probability more interactive and engaging. Here’s how you can leverage it:\n\nClarify Concepts:\nAsk ChatGPT to explain concepts in simple terms or elaborate on topics you find difficult:\n\n“Explain the concept of a probability distribution with an example.”\n\nGenerate Examples:\nUse it to create additional examples for practice:\n\n“Can you give me an example of a random variable and how it applies in finance?”\n\nDebug R Code:\nIf you encounter issues with your R code, paste the code and ask:\n\n“Why does this R code not run, and how can I fix it?”\n\nPractice Exercises:\nRequest custom exercises:\n\n“Create three exercises to practice calculating probabilities for dice rolls.”\n\nSimulate Interactive Discussions:\nSimulate discussions with ChatGPT to test your understanding:\n\n“I think the variance of a constant is zero. Am I correct? Explain why or why not.”\n\nLearn Best Practices in R:\nAsk for tips to improve your coding practices:\n\n“What are the best practices for writing clean and efficient R code?”\n\n\nImportant Note:\nWhile ChatGPT is a powerful learning tool, remember to verify the outputs, especially for complex calculations, and always critically evaluate its suggestions. One such tool you might consider for cross checking is Wolfram | Alpha, which you can find here: https://www.wolframalpha.com/ in a free version-",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "01-lecture1.html",
    "href": "01-lecture1.html",
    "title": "1  First probability ideas and first steps in R",
    "section": "",
    "text": "1.1 Tossing a fair coin: First Probability ideas.\nLets start with a classic and basic example of a probability model: Tossing a fair coin. When probability theorists talk of a fair coin they mean that the coin has equal chances of coming up heads as coming up tails. When the coin is tossed it is uncertain whether it will ultimately come up Heads or Tails.\nFigure 1: Tossing a coin\n?fig-coin-toss visualizes such a process.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>First probability ideas and first steps in R</span>"
    ]
  },
  {
    "objectID": "01-lecture1.html#rolling-a-die",
    "href": "01-lecture1.html#rolling-a-die",
    "title": "1  First probability ideas and first steps in R",
    "section": "",
    "text": "1.1.1 Random experiments, sample space, events\nIn the theory of probability a process leading to an uncertain outcome is called a random experiment. The example of throwing a die helps us to give a precise meaning to the notion of an uncertain outcome. While we can imagine in principle that the die lands on one of its corners and this is one outcome, we agree on the outset that we are going to consider the (practically relevant cases) that it will land on one of the faces.\nThe collection of all possible outcomes of a practical or conceptual random experiment is called in probability theory a sample space. While the sample space of throwing a die is an idealization it is exactly this idealization which simplifies the theory without affecting its applicability. The basic outcomes in the random experiment of throwing a die are that the die lands such that the upward showing face shows a 1 a 2, 3, 4, 5 or a 6. In the theory the collection of basic outcomes is denoted as a set. Thus the sample space of throwing a die is given as the set \\({\\cal S} = \\{1,2,3,4,5,6\\}\\).\nThe sample space \\({\\cal S}\\) is the set of all basic outcomes. The subsets of the sample space are often called events in probability theory. An event could be - for example - an outcome where the die shows an upward looking face with an even number \\(A = \\{2,4,6\\}\\).\n\n\n1.1.2 The role and nature of idealizations in applications\nIdealizations of the kind we discussed for the throw of a die are standard in probability and we will encounter them again and again. For example the movement of a stock price is often though of as a conceptual random experiment. When we try to agree on what is the appropriate sample space of this experiment, we can say that the price can not fall below 0 but it is hard to agree on what will be the highest possible price. In the probabilistic treatment of stock prices, which we will discuss later in our course, it is for instance common to assume that the sample space of this random experiment is the entire interval of non-negative real numbers \\({\\cal S} = [0, \\infty)\\).\nMany of us would hesitate to claim that the price might rise without bound. Yet many models in applied Finance are based on such an assumption. The models allow arbitrary price hikes but with arbitrary small probability as the price gets higher and higher. Practically it does not make sense to believe that a security price can become arbitrarily high. The use of arbitrarily small probabilities in a financial model might seem absurd but it does no practical harm and makes the model simple and convenient to use. Moreover, if we seriously introduced an upper bound on a security price at \\(x\\) it would be also awkward to assume that it is impossible that it could be just a cent higher, an assumption equally unappealing than assuming it can get in principle arbitrarily high.\n\n\n1.1.3 Classical Probability: Measuring uncertainty\nProbability is a measure of how likely an event of an experiment is. But how could we measure chance? Here is the first big idea of probability theory and how the originators thought about it.1 How do you measure anything? If you think of length, for example, you take an arbitrary standard you agree on and then count. The originators of probability theory pursued the same idea with chance: To measure probability you choose equally probable cases and then count.\n1 In this discussion I use chapter 1 in Diaconis and Skyrms (2019)The probability of an event \\(A\\) according to the originators of the theory of probability is then \\[\\begin{equation}\nP(A) = \\frac{\\text{Number of cases where $A$ occurs}}{\\text{Total number of cases}}\n\\end{equation}\\]\nThus, if we want to know the probability of the die ending up on a face such that an even number is shown (2,4,6) we have to compute according to this notion \\(3/6\\) (since the total number of cases are six basic outcomes) which is a chance of \\(50 \\%\\).\nNote that this classical notion of probability has a few interesting consequences, which we will discuss in more detail later but which already now naturally flow from this basic idea of measuring chance.\n\nProbability is never negative.\nIf an event \\(A\\) occurs in all cases \\(P(A)=1\\).\nIf \\(A\\) and \\(B\\) never occur in the same case, then \\(P(A \\,\\text{or}\\, B) = P(A) + P(B)\\).\n\nIn particular then the probability that an event does not occur is 1 less the probability that it occurs: \\(P(\\text{not}\\, A) = 1 - P(A)\\).\nLet us interrupt here our discussion of probability for a moment and ask how we can make good on our promise to make these ideas tangible, so we can play with them.\nFor this we will need the computer. Since we will talk to the computer in R, it is now the right time to look at the die rolling example from the perspective of R and dive into some of its basic concepts.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>First probability ideas and first steps in R</span>"
    ]
  },
  {
    "objectID": "01-lecture1.html#rolling-die-on-computer",
    "href": "01-lecture1.html#rolling-die-on-computer",
    "title": "1  First probability ideas and first steps in R",
    "section": "1.2 Rolling a die on the computer: First steps in R",
    "text": "1.2 Rolling a die on the computer: First steps in R\n\n1.2.1 The R User Interface\nBefore we can ask our tool to do anything for us, we need to know how to talk to it. In our case RStudio allows us to talk to our computer. It works like any other application. When you launch RStudio on your computer, in figure @ref(fig:rstudio-start-screen) you see a screen looking like this:\n\n\n\n\n\nThe RStudio startup screen\n\n\n\n\nIn this picture you see a screenshot of my RStudio screen. Interacting with the app is easy. You type commands via your keyboard at the prompt, which is the &gt; symbol. You find this symbol in the RStudio pane called Console. You can see it in the left pane in the screenshot. You send the command to the computer by pressing enter. After you have pressed enter, RStudio sends the command to R and displays the result of your command with a new prompt to enter new commands, like this:\n\n1+1\n\n[1] 2\n\n\nLet me pause to explain what you see here in this code example. First you see a light-gray box containing the command 1+1. This is an instance of a so called code chunk. Moving the cursor to the right upper corner of the chunk, will display a copy icon and you can click this icon to copy the code to the computer’s clipboard and then paste it at the prompt of your console (or for that matter anywhere else) and run it in R studio, if you wish. In the code-chunk the R-prompt &gt; is not displayed. This symbol of the prompt is only shown in the Console itself.\nWhen the code is executed, you see the result in the second light-gray box, just below the first one. It starts with a double hash ##, indicating that it shows an output of running the above code chunk and then displays the output as it would appear in the command window [1] 2.\nThe [1] means that the line begins with the first value of your result. For example, if you enter the command 20:60 at the prompt of your console which means in the R language, “list all the integers from 20 to 60” and press enter you get:\n\n20:60\n\n [1] 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44\n[26] 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60\n\n\nmeaning that 20 is the first value displayed in your result. Then there is a line break because not all values can be displayed on the same line and R tells you that 45 is the 26-th value of the result.\nThe colon operator : is a very useful function in R which we will need often. It allows us to create sequences of every integer between two given integers.\nR needs a complete command to be able to execute it, when the return key is pressed. Lets see what happens, if a command is incomplete, like for instance &gt; 5*.\nIn this case R will show the expression followed by a + instead of showing a new prompt. This means that the expression is incomplete. It expects more input. If we complete the expression, say like\n&gt; 5*\n+ 4\nthe expression can be evaluated and a new prompt is shown in the console.\nIf you type a command that R does not understand, you will be returned an error message. Don’t worry if you see an error message. It just is a way the computer tells you that he does not understand what you want him to do.\nFor instance, if you type 5%3 you will get an error message like this\n&gt; 5%3\nError: unexpected input in \"5%3\"\n&gt;\nSometimes it is obvious why a mistake occurred. In this case, that R just does not know what to do with the symbol %. It has no meaning in this context. Sometimes it is not so obvious what the error message actually means and what you might do about it.\nA useful strategy in this case is to type the error message into a search engine and see what you can find. The chance is very high that others encountered the same problem before you and got helpful advice how to fix it from other users on the internet. One site, we find particularly helpful for all kinds of questions related to R and R programming is https://stackoverflow.com/. Try it at the next opportunity.\nNow with this basic knowledge, we can already make the first step to create a die on the computer using R. If you think of a physical die, the essential thing that matters are the points on its six sides. If you throw the die it will usually land on one of these sides and the upward showing side of the die shows the number of points. The colon operator : gives us a way to create a group of numbers from 1 to 6. R gives us the result as a one dimensional set of numbers.\n\n1:6\n\n[1] 1 2 3 4 5 6\n\n\nLets use these first steps in R to recap the probability concepts we have learned using this example of the six sided die: A basic outcome of rolling a six-sided die is for example 6 if the upper side after rolling the die happens to be the side with 6 points. The sample space of the experiment of rolling a six-sided die is the set \\({\\cal S} = \\{1,2,3,4,5,6\\}\\). In probability theory we often use the symbol \\({\\cal S}\\) or \\(S\\) for sample space. In many probability texts the sample space is also often denoted by the symbol \\(\\Omega\\) the Greek letter for (big) Omega. A random experiment in this example is the rolling of the die. The outcome is uncertain but once the die is rolled the outcome can be determined precisely. The event that the outcome is a display of 10 points is the empty set \\(A = \\emptyset\\). The symbol \\(\\emptyset\\) comes from set theory and means the set containing no elements. This event can contain no elements because we can not get a score of 10 by rolling a six sided die.\n\n\n1.2.2 Objects\nYou can save data in R by storing them in objects. An object is a name, you can choose yourself to store data. For example, if you choose to store the value 6 in an object called point_six, you would type:\n\npoint_six &lt;- 6\n\nat the prompt. R will the store the value 6 in the object called point_six, which you can use to refer to the value. If you type the name of your object at the prompt, R will display the value you have assigned. A useful key combination for typing the assignment operator &lt;- is to use the key combination ALT _. At the R prompt R will automatically print an assignment operator.\nNow if you type the name of the object and press enter, R will display the value or values stored in it, like this:\n\npoint_six\n\n[1] 6\n\n\nNow you can use the name of the object to refer to its value. For instance, you could divide point_sixby 2and get a meaningful result\n\npoint_six/2\n\n[1] 3\n\n\nNow to make our die more tangible and useful, let us store it in an R object by typing the following command at the prompt. This command creates an object with name die and assigns the vector 1,2,3,4,5, 6 to it.\n\ndie &lt;- 1:6\n\n\n\n\n\n\nThe RStudio Environment pane keeps track of the objects you have created\n\n\n\n\nYou can now see in the right upper Environment pane in figure @ref(fig:rstudio-screen-with-command) that R shows you that there is an object with the name die that it consists of integers 1,2,3,4,5. As you create more objects they will be stored in the Environment pane and are ready for your reference, unless you delete them. You can remove or delete an object by typing rm(object) or by assigning the value die &lt;- NULL which would also remove the object from your environment or workspace.\nYou can name your objects almost anything with a few exceptions. An object name must not start with a number. There are some special symbols which can also not be used in object names, like ^, !, $, @, +, -, /, *. Note that R is case sensitive and distinguishes small and big letters. If you assign a new value for an object you have already created, R will overwrite the object without warning.\nYou can see which objects are currently created and available for you in the Environment pane of your session of by typing ls(). The UNIX users among you will recognize this command from the unix shell, where it displays the files in a directory.\nBefore we learn how we can actually roll our die and perform a random experiment with it, let us briefly use the opportunity to explain a few things about how R does computations. We have already explained that we can use the object name to refer to the value. So for instance if we type\n\ndie*die\n\n[1]  1  4  9 16 25 36\n\n\nThis might irritate some of you because we have called the object a vector. In linear algebra multiplication of vectors is only allowed if there is an inner product. What happens here, if we use * the multiplication operator is that R does an element-wise multiplication of the six numbers of our die. Of course R allows to take an inner product as well, but this needs a different operator. To compute an inner product, we would type\n\ndie %*% die\n\n     [,1]\n[1,]   91\n\n\nNow R displays the result as a vectors with one row and one column, which is denoted in the output by [ , 1] for the column and [1, ] for the row. We will learn later more about the use and the meaning of this notation in R.\nThe element wise execution R usually uses also means that when you, for example type\n\ndie - 1\n\n[1] 0 1 2 3 4 5\n\n\nR would subtract 1 from every component in the vector die.\nAnother specific behavior of R, you need to know about is called recycling. If you give R two vectors of different length in an operation, R will repeat the shorter vector as long as it is of equal length with the longer one. For example, if you have: ::: {.cell}\ndie + 1:2\n\n[1] 2 4 4 6 6 8\n\n:::\nyou see that R adds 1 to 1 and 2 to 2 and then starts over again by adding 1 to 3 and 2 to 4 and then starts over once again by adding 1 to 5 and 2 to 6. If the longer vectors is not a multiple of the shorter one, R recycles but the cuts off. It will give you a warning though. ::: {.cell}\ndie + 1:4\n\nWarning in die + 1:4: longer object length is not a multiple of shorter object\nlength\n\n\n[1] 2 4 6 8 6 8\n\n:::\nWhile this might seem awkward to some of you, we will see that for data manipulation element-wise execution is often extremely useful. It allows to manipulate groups of values in a systematic yet easy way.\n\n\n1.2.3 Functions\nR contains many functions which we can use to manipulate data and compute things. The syntax for using a function is very simple: You type the function name and put the value of the function argument in parentheses. Here we use for illustrations the function of the square root sqrt(): ::: {.cell}\nsqrt(4)\n\n[1] 2\n\n::: or rounding a number: ::: {.cell}\nround(3.1415)\n\n[1] 3\n\n::: The data you write in the parentheses are called the function arguments. Arguments can be all sorts of things: raw data, R objects, results from other functions.\nIf functions are nested, R evaluates the innermost function first and then goes on to the outer functions. To see examples of all these instances you can take ::: {.cell}\nmean(1:6)\n\n[1] 3.5\n\nmean(die)\n\n[1] 3.5\n\nround(mean(die))\n\n[1] 4\n\n::: for example.\nFor simulating random experiments, R has the very useful function sample(). With this function we can roll our die on the computer and conduct actual random experiments.\nThe function takes as arguments a vector names x and a number named size. sample will return size elements randomly chosen from the vector x. Lets say: ::: {.cell}\nsample(x = 1:4, size = 2)\n\n[1] 2 1\n\n:::\nIn this case sample has chosen 4,1 from the vector x = (1,2,3,4) at random.\nIf we want to roll the die in our computer we can thus pass the die as an argument to sample and use the number 1 for the size argument. Lets do a few rolls with our die ::: {.cell}\nsample(x = die, size = 1)\n\n[1] 3\n\nsample(x = die, size = 1)\n\n[1] 2\n\nsample(x = die, size = 1)\n\n[1] 6\n\nsample(x = die, size = 1)\n\n[1] 5\n\n::: These are the random outcomes of our consecutive rolls. It is as if we had thrown an actual die but in this case we have done the same thing on the computer. Isn’t it cool that this is possible at all? The sample() function will remain our good friend throughout this course.\nR functions can have many arguments, but they need to be separated by a comma.\nEvery argument in every function has a name. We specify which data are assigned to the arguments by setting a mathematical equal sign = between the name and the data. Names help us to avoid passing the wrong data and thereby mixing up things or committing errors. But using names is not necessary. If we just wrote ::: {.cell}\nsample(die,1)\n\n[1] 3\n\n::: R would also know what to do. It is not always clear which names to use for a function. If you are not sure, you can use the function args() to look it up. Here we take the function roundas one example. ::: {.cell}\nargs(round)\n\nfunction (x, digits = 0, ...) \nNULL\n\n::: Note that the digits argument in the round function is already set to 0. Frequently R functions come with optional arguments. These arguments are optional because the come with a default value, which is 0 in case of the round function.\nWe recommend that you write out argument names as a rule. It gives clearer code and avoids errors. If you don’t write argument names, R matches your values to the arguments of the function by order.\n\n\n1.2.4 Writing your own functions\nNow we are ready to write our own function to roll the die in our computer. Each function in R has the same elements: A name, a function body of code and a set of arguments. To write your own function, you have to write up all of these parts and save them in an R object. The syntax is:\nmy_function &lt;- function() {}\n\nThe name here is my_function, next comes the expression function() which needs to be assigned. The names of the function arguments have to be written between the parentheses. Then we have to write the actual code within the braces {}.\nTo do this for the die, lets write a function named roll_die. ::: {.cell}\nroll_die &lt;- function(){die &lt;- 1:6 \n                         sample(die, size = 1)}\n:::\nNow we can roll our die for a few times to show how the function works ::: {.cell}\nroll_die()\n\n[1] 3\n\nroll_die()\n\n[1] 1\n\nroll_die()\n\n[1] 1\n\nroll_die()\n\n[1] 6\n\nroll_die()\n\n[1] 5\n\n::: Note that in our function roll_die() has no arguments, just the function body. This is perfectly legitimate in R. It is important that when we call the function we have to call it with the parenthesis like roll_die(). If we only call the name roll_die, R will display the code in the function body.\nA final remark in the sample function is in place here. If we look at the arguments of sample using the args function we see ::: {.cell}\nargs(sample)\n\nfunction (x, size, replace = FALSE, prob = NULL) \nNULL\n\n::: Lets do not discuss all the details of this output but concentrate for a moment on the replace argument. What does this mean?\nAs we saw previously we can use the sample function to model the rolling of our die. If we set the size argument to 1 we get the roll of one die. If we set the size argument to n, we would simulate the rolling of n dies. But now the replace argument becomes crucial. As we can see in the output of the args function replace has a default value FALSE. This is a logical argument. It tells R, for example, that if we set size = 2, meaning that two dice are rolled, if the first dice shows, say a value of 3, the second die cannot show 3 as well.\nThis is clearly not what we have in mind when we model the rolling of 2 dice. It should be possible that both dies show the same value. To enable this behavior of the sample function, we have to change the default value of the replace argument to TRUE. Then R chooses a random draw from all of the six possible values for all dice rolled.\nCongratulations ! You have written your first R function for conducting a simple random experiment. Let me remind you once again: Think of the parentheses as a trigger that tells R to run the function. If you omit the trigger R just prints the body of the function. When you run a function, all the code in the function body is executed and R returns the result of the last line of code. If the last line of code does not return a value neither will R.\n\n\n1.2.5 Arguments\nImagine we remove the first line of code in our function body and changed the name die in the sample function to “ball”. ::: {.cell}\nroll_die2 &lt;- function(){sample(ball, size = 1)}\n::: If we call the function now, we will get an error. The function call roll_die2() will result in the error message Error in sample(ball, size = 1) : object 'ball' not found (try it!)\nWe could supply ball when we call roll_die2 if we make ball an argument of the function. Lets do this: ::: {.cell}\nroll_die2 &lt;- function(ball){sample(ball, size = 1)}\n::: Now the function will work as long as we supply ball when we call the function. ::: {.cell}\nroll_die2(ball = 1:6)\n\n[1] 3\n\n::: Note that we still get an error, if we forget to supply ball argument. This could be avoided if we give the function a default argument ::: {.cell}\nroll_die2 &lt;- function(ball= 1:6){sample(ball, size = 1)}\n::: Now if we type: ::: {.cell}\nroll_die2()\n\n[1] 1\n\n::: everything works, just as intended.\n\n\n1.2.6 Scripts\nSo far we have worked by interacting with the console. But what if you want to edit your functions? It would be much easier, if you could use a draft of your code and work form there. This can be done by using a script.\nYou create a script by going to File &gt; New File &gt; R script in the menu bar of RStudio. Using scripts is the standard way to write code in R. It not only helps you to keep track of your code, save it and edit it later. It also makes your work reproducible. You can edit and proofread your code and share it with others. To save your script go to File &gt; Save As in the menu bar.\n\n\n\n\n\nThe RStudio Script\n\n\n\n\nRStudio has many useful features to help you work with scripts. You can for instance automatically execute a line in a code by using the run button. You can also execute sections of code or the entire script. The entire script is executed by running the Source button. For all these commands there are key short cuts which you will learn as you work more with RStudio and R.\nFrom now on you should write all your R-code for this course in scripts. Make a new folder for the scripts you write and store your R-code there from now on.\n\n\n1.2.7 Using packages and finding Help\nWe have now a function which we can use to simulate the rolling of a die, roll_die(). If the die is fair it should be the case that if we roll the die often, all numbers should occur about equally often. The die should not be weighted in favor of a particular value.\nOne way to learn whether our die is fair are repetition and visualization. These are tools we will need all the time, when working with data and when doing probability. While R has many useful functions, one of the great powers is that R is constantly extended by a huge community of users by providing packages.\nPackages are add on functions, which will not be available when you install R. They need to be installed and loaded before you can use them. Since packages are such a powerful tool in R we need to introduce what they are and how to use them in the beginning.\n\n\n1.2.8 Packages\nThere are many visualization tools in R that come with the basic installation. Since the point we want to make here is about packages, we will use a visualization function which is part of the add on package ggplot2, a very popular package for making all kinds of graphs. ggplot2 is not part of the base-R distribution. It has to be therefore loaded before we can use it.\nThere are many additional functions provided with this package. Indeed you could run a whole course on just that 2 For the point we want to make here we will use just one of them, called qplot(), a shorthand for for quick plot.\n2 A very good starting point is for instance Healy (2019), in case you are interested. Also a good source is the first chapter in Wickham and Grolemund (2017).Since qplot() is a function in the package ggplot2, we first need to install this package. To install a package you need to be connected to the internet. If you have internet connection go to the command line and run at the command line: install.packages(\"ggplot2\").\nR displays what is happening while executing the command. Don’t worry if you don not know what all of these messages exactly mean and don’t panic that they are displayed in red. All packages can be installed like this. You have just to enter the correct name in the function install.packages(). The lower right pane in the RStudio software alternatively provides a tab called Packages. Using this tab, you can also install R packages interactively by clicking the install button on the upper left corner of the Packages tab.\nAfter installation the package is on our hard-drive but it can not yet be used. To use the package it has to be loaded. This is done with the command library. To load the ggplot2 package we type ::: {.cell}\nlibrary(\"ggplot2\")\n::: and hit the return key. Many things could be said about the R package system and you will learn it in more detail as we go along in our course. For the moment the most important thing to remember is that a package needs to be newly loaded whenever you want to use it in a new R session.\nTo check whether our dies is fair, we need to roll it many times. R provides a function, that does this for us. This function is called replicate() and provides an easy way to repeat a command many times. The number of times we want to repeat something is given as an argument to the replicate function.\nNow lets roll our die 100 times and save the result in an object we call rolls: ::: {.cell}\nrolls &lt;- replicate(100, roll_die())\n::: We now use the qplot()function from the ggplot2 library to make a quick visualization, by typing the command qplot(rolls). I include the resulting picture in the following figure ::: {.cell layout-align=“center”} ::: {.cell-output-display}  ::: ::: If you try this and your picture looks a bit different from mine, don’t worry. This is as things should be. I have stored the picture after one particular run of the replicate function and saved it in my figures folder to these lecture notes. Each time you run the replicate function anew a new random outcome is stored which will look not exactly the same as any other or course. This is what randomness does to the outcome of rolling a die.\nIt looks like every value occurred roughly 16 times but there is still quite some variation. For instance, the value 3 seems to occur more than 20 times whereas the value 2 occurs less than 15 times.\nMaybe we have to give it another trial with more replications. With the computer we can do this with a fingertip. Let us roll our die 10000 times and plot the result.\n&gt; rolls2 &lt;- replicate(10000, roll_die())\n&gt; qplot(rolls2m bindwidth = 1)\nNow the picture looks better.\n\n\n\n\n\nFrequencies of 1, 2, 3, 4, 5, 6 after rolling our virtual die 10000 times\n\n\n\n\nWe will learn in our course why the picture get better as we increase the number of rolls of the die. For the moment, let us just state that at least for this case it seems that there is no significant visual evidence that our virtual die is loaded.\n\n\n1.2.9 Getting Help\nWe have now learned a tiny number of R functions and we have written one function ourselves. We have learned how to make use of functions provided by packages.\nIt would be overwhelming to memorize and learn them all. In R, fortunately, every function comes with a detailed documentation and with its own help page. You need to learn how to use this source right from the beginning.\nTo access the help page of a function you type the function name preceded by a question mark at the prompt, like this ::: {.cell}\n?sample\n:::\nThen, after you have pressed the return key, a help page is opened in the right lower pane under the help tab as shown in @ref(fig:helpinr) ::: {.cell layout-align=“center”} ::: {.cell-output-display}  ::: :::\nThis help page has a particular structure that you will find for every other R function no matter whether it is provided by the base installation or by a package. In the upper left corner you see the name of the function (sample) and in curly brackets next to it the term base, which means that this is a function in the R base installation. Then you see a headline about what the function does.\nFrom the top of the page, you then first see the field Description. This is a short description what the function does. Here it says\nDescription\nsample takes a sample of the specified size from the elements of x using either with or without replacement.\nThe next field is Usage. It gives you the function description with the arguments. Here for example\nUsage\nsample(x, size, replace = FALSE, prob = NULL)\n\nsample.int(n, size = n, replace = FALSE, prob = NULL,\n           useHash = (!replace && is.null(prob) && size &lt;= n/2 && n &gt; 1e7))\n           \nThe first line in Usage should by now be familiar. Don’t worry about the second line. The function can obviously do more than we know so far.\nNext comes a list of arguments the function takes and what type of information R expects you to provide, as well as what R will do with this information. Here it says for example\nArguments\nx   \neither a vector of one or more elements from which to choose, or a positive integer. See ‘Details.’\n\nn   \na positive number, the number of items to choose from. See ‘Details.’\n\nsize    \na non-negative integer giving the number of items to choose.\n\nreplace \nshould sampling be with replacement?\n\nprob    \na vector of probability weights for obtaining the elements of the vector being sampled.\n\n...\n\nWe omit some information here.\nThen comes a field called Details which gives a more in-depth description of the function. The next field is called Value. It describes what the function returns when you run it. Then we have a reference to related R functions under the field See. Finally there is a field called Examples. This field contains example code that is guaranteed to work. It shows a couple of different cases how you can use the function in practice.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>First probability ideas and first steps in R</span>"
    ]
  },
  {
    "objectID": "01-lecture1.html#coincidences",
    "href": "01-lecture1.html#coincidences",
    "title": "1  First probability ideas and first steps in R",
    "section": "1.3 Application: Coincidences and the Blockchain",
    "text": "1.3 Application: Coincidences and the Blockchain\n\n1.3.1 The birthday problem\nWe learned now some basic notions of probability and of R with the example of the rolling of a fair die. It is really surprising what already can be done by just applying the simple ideas we have just learned. The application we want to show you now is known to probability theorists as the birthday problem. It originates in a piece of recreational maths and math-puzzles but it reaches out until cryptography, computer security and blockchain architecture. It also gives us an opportunity to apply some of our newly acquired R-knowledge.\nThe starting question in the birthday puzzle is: What is the probability that at least two people in a room share the same birthday, when we neglect things like leap years, and when we assume that birthdays on any day of the year are equiprobable and the birthdays of the people in the room are independent. We have no twins for example. Perhaps some of you have already seen this problem before. If not, the result may surprise you. Even if you saw the birthday problem before, perhaps not many of you have seen the connection to the cryptography and the blockchain.3\n3 We follow here the discussion in Diaconis and Skyrms (2019)First, observe that we took our assumptions such that we are in the frame of classical probability like the originators of the field thought about it.\nNow for the sake of familiarizing ourselves with the new concepts, let us try to map the birthday problem into the probability notions we learned so far.\nThe sample space is the set of possible outcomes of the experiment. Assume we have \\(n\\) people in the room. Since each person can have a birthday at any of the 365 days in the year (note that we assumed we exclude leap years) and we have \\(n\\) people in the room, the possible basic outcomes are \\(365 \\times 365 \\times 365 \\cdots 365\\) taken \\(n\\) times. This will produce a set with \\(365^{n}\\) ordered \\(n-tuples\\) or sequences of birthdays. This is the sample space of this experiment, written as \\({\\cal S} = \\{x | x \\in 365^n\\}\\) in set theoretic notation. It means the sample space is the set of all ordered \\(n-tuples\\) from the Cartesian product \\(365^n\\).\nRemember that in mathematics, a Cartesian product is a mathematical operation that returns a set (or product set or simply product) from multiple sets (in this case the sample space, \\({\\cal S}\\). That is, for sets \\(A\\) and \\(B\\), the Cartesian product \\(A \\times B\\) is the set of all ordered pairs \\((a, b)\\) where \\(a \\in A\\) and \\(b \\in B\\).\nNow given this sample space we can assign a probability to the event that two people chosen at random will have the same birthday. The denominator will this be \\(365^n\\). The nominator for this probability will be much more straightforward to figure out, if we compute the complement. We discussed before that the probability of the complement of an event is 1 minus the probability of the event. Translated to the birthday problem, this means we look for the 1 minus the probability that that all birthdays are different. The probability that the second person has a different birthday from the first is \\(\\frac{364}{365}\\). If they are different the probability that the third person has a different birthday from them is \\(\\frac{363}{365}\\) and so on for all \\(n\\) in the room. Thus the probability of a shared birthday in the room is: \\[\\begin{equation*}\nP(\\text{at least two people share birthday}) =\n1 - \\frac{365 \\times 364 \\times 363 \\cdots \\times 365 - n +1}{365^n}\n\\end{equation*}\\] Now there is an additional thing we did not yet introduce and which we will learn about in the next lecture. This refers to our assumption that the individual birthdays are independent. For the moment you need to take the following fact on faith: The probability of independent events is the product of the probability these events.\nNow comes the surprise for those of you who did not already see the birthday problem. Assume the group size of people is 23. Let us compute the birthday coincidence probability. For this computation we make use of the R function prod() which takes a vector of numbers as input and computes their product. For \\(n=23\\) we need the list of numbers from 365 to 343. Now we can use the : operator and take advantage from one of its cool properties. If we formulate the command as 365:343 then the colon operator will give us a descending list of integers starting at 365 and ending at 343. Then the probability can be computed as ::: {.cell}\n1 - prod(365:343)/365^23\n\n[1] 0.5072972\n\n::: We have used the operator ^ which is needed to compute powers. Now we see from our computation that with 23 people the probability is already larger than 50 %. Quite stunning. You can now verify yourself that with 50 people this probability is already at 97 %.\n\n\n1.3.2 An R function to compute birthday probabilities\nNow let us use our knowledge about how to write R functions to write a function to compute birthday probabilities. The function argument is the number \\(n\\) of people in class. The coincidence probability is given by the formula we have derived. Now here is how we could go about writing this function: ::: {.cell}\nbirthday_collisions &lt;- function(n){\n  1 - prod(365:(365-n+1))/365^n\n}\n::: Now lets verify what I have claimed before about the group size 50. ::: {.cell}\nbirthday_collisions(50)\n\n[1] 0.9703736\n\n::: Voila, indeed with 50 people in the group the collision probability is already at 97 %.\n\n\n1.3.3 Determining birthday collisions by simulation\nNow this was an argument derived analytically and then we just packed the derived result into a function to compute the exact birthday-collision probabilities. Here is how we could figure out these probabilities by simulation, even with the minimal tools we have learned so far.\nLet us simulate first birthdays for 23 people in a room using the sample function. We stick to the assumption that our year has 365 days (no leap years), and that all birthdays are equally likely, so we can sample from the list of days from 1 to 365 with the sample function which we have already encountered.\nWe need to take care to set the replace argument in the sample function to the value TRUE. This is because we always draw for every person in the room from the same list of values. If one birthday is drawn it is possible in principle that later in the process the same birthday is drawn again. Before, when we worked with only one die we did not need to care whether sample drew with replacement or not. ::: {.cell}\nb_23 &lt;- sample(1:365, 23, replace = TRUE)\n::: This little piece of code is to be read in the same way as before when we built the process of rolling a die on the computer. We sample 23 values from the vector \\(1,2,3,\\cdots,365\\) without replacement. Think about a situation where I use uniform random numbers to call 23 people in your group and write the birthdays I get in this way into the object b_23.\nHere is how I can find the number of matches in b_23. R has a built in function, which is called unique(). So if there were two people with the same birthday in b_23, applying unique() to b_23 would only keep one value. Now clearly if we subtract the length of the resulting object from 23 we get the number of collisions in b_23. Fortunately we can use the R function length() to achieve this task. length() computes the length of any object we give it as an argument. ::: {.cell}\nm_23 &lt;- 23 - length(unique(b_23))\n::: So for instance if sample() drew 23 different birthdays m_23 would be 0.\nLet’s pack this process into a function: ::: {.cell}\nsim_23 &lt;- function(){\n  b_23 &lt;- sample(1:365, 23, replace = TRUE)\n  (23 - length(unique(b_23)))\n}\n::: Now we can repeat this process many times - say 10000 times - using the replicate function. ::: {.cell}\nsimprobs_23 &lt;- replicate(10000, sim_23())\n:::\nNow how do we get from here to probabilities? Here we anticipate and introduce a new probability concept which we will discuss in more detail in the next lecture but which you perhaps already came across a few times.\nThis concept could be called the relative frequency probability . In this concept the probability of an event \\(A\\) is defined as \\[\\begin{equation*}\nP(A) = \\frac{\\text{Number of times $A$ occurs in repeated identical trials}}{\\text{Total number of trials in a random experiment}}\n\\end{equation*}\\] Applying this concept to our data generated by the replicate function and stored in b_23 would require two things. First we would have to count the number of times we saw a 1,2 or more matches, which in our case means 1,2 or more birthday collisions, add up the count and divide by the number of replications. Clearly it is also easier here to work the other way round. We count the number of no collisions and use the complement rule, by computing 1 minus the relative frequency of no collisions. Let us do that.\nNow this is clearly too tedious to do by hand. We will discuss systematically in the next lecture how to refer to individual values in an R object and select and operate on ranges of values etc.\nFor the moment, look at the next step just as a piece of magic and don’t worry if you do not exactly understand the syntax at the moment.\nIn the numerator I ask R to count the number of 0s (no birthday collisions) in the object simprobs_23 and then I divide it by 10000, just as in the definition of relative frequency probability. Then I compute 1 minus this relative frequency ::: {.cell}\n1 - length((simprobs_23[simprobs_23 == 0]))/10000\n\n[1] 0.5034\n\n::: Voila, this is pretty good, isn’t it? Remember that the analytical solution we just got a bit earlier was 0.5072972\nIsn’t this cool? Instead of using formal reasoning we built a random experiment on the computer and came up with a pretty good approximation of the collision probability.\nLet’s check the result with 50 for the sake of completeness and for the sake of practice, with an experiment with 10000 trials. I now stitch all steps together. ::: {.cell}\nsim_50 &lt;- function(){\n  b_50 &lt;- sample(1:365, 50, replace = TRUE)\n  (50 - length(unique(b_50)))}\n\nsimprobs_50 &lt;- replicate(100000, sim_50())\n1 - length((simprobs_50[simprobs_50 == 0]))/100000\n\n[1] 0.97016\n\n::: Pretty amazing! Before we got the exact value as 0.9703736.\nBut now let us stay still with the birthday problem but now get away from this playful application to something really serious: Cryptography.\n\n\n1.3.4 Hash-functions and the blockchain\nThe birthday problem is the canonical model for the probabilistic study of coincidences of all kinds. A particular important application of this idea is in cryptography, and its concept of so called hash-functions.\nA hash-function maps a string of arbitrary but finite length to a fixed length string of output.4 A very frequently used hash-function in practice is the function SHA-256, which maps its input to a string of 256 bits5. So, you could for instance give the text of these lecture notes as an input to SHA-256 and it would map this into a 256-bit string, which functions like a finger print of this text. This function is an instance of a special from of mappings called a one-way-function meaning that it is easy to evaluate or compute but it is practically impossible to learn from the value the initial argument by computing the inverse.\n4 We have taken this discussion from https://brilliant.org/wiki/birthday-paradox/5 A bit, short for binary digit, is defined as the most basic unit of data in telecommunications and computing. Each bit is represented by either a 1 or a 0Hash-Functions are key pillars of modern cryptography, where they play a major role in message authentication. This is because it is impossible to modify the input without significantly changing the output. So in our previous example, if you only deleted or added a comma to these notes and hash-them again they would hash into a completely different value than the previous version which still was without this minor change. Comparing the hash-values would reveal immediately that something has changed.\nThe collision problem for hash-functions is formally equivalent to the birthday problem. The event we are interested in is that at least two input strings hash-to the same value. Again it is easier to think about the complementary event that all inputs hash to a different value.\nIf the range of the hash-function is \\(M\\) and the hash-function maps into a 256 bit string then there are \\(2^{256}\\) basic outcomes. Since the hash-function maps a large string onto a smaller string it is possible that there are two different strings \\(x \\neq y\\) mapping to the same value \\(\\text{hash}(x)=\\text{hash}(y)\\). This would be a problem for message authentication because it would give the same “fingerprint” for two different strings.\nFor a cryptographically secure hash function it is therefore required that the probability of such a collision should be small enough to exclude a collision in all practically relevant circumstances.\nNote that this is a problem formally similar to the birthday problem. In the cryptography context we ask, how many values does a potential attacker have to hash through SHA-256 before the probability of a collision is larger than a certain threshold?\nThe probability of no-collision (\\(nc\\)) with \\(n\\) hashed-messages through a SHA-256 hash function is \\[\\begin{equation*}\nP_{nc}(n) = 1 \\times \\left(1 - \\frac{1}{2^{256}}\\right)\\times\n\\left(1 - \\frac{2}{2^{256}}\\right) \\times \\cdots \\times \\left(1 - \\frac{(n-1)}{2^{256}}\\right)\n\\end{equation*}\\]\nNow to do the estimation of the threshold we use an approximation, which works with a simple property of the logarithm: \\(\\log(1-x)\\approx -x\\) when \\(x\\) is small. Thus for \\(n\\) much smaller than \\(M\\), or \\(n \\ll M\\), we can write the no-collision probability approximately as \\[\\begin{align*}\nP_{nc}(n) &\\approx 1 \\times \\exp\\left(-\\frac{1}{2^{256}}\\right) \\times \\exp\\left(-\\frac{2}{2^{256}}\\right) \\times \\cdots\n\\times \\exp\\left(-\\frac{(n-1)}{2^{256}}\\right) \\\\\n&\\approx 1 \\times \\exp\\left(-\\frac{(1+2+3+...+(n-1))}{2^{256}} \\right) \\\\\n&\\approx \\exp\\left(-\\frac{n \\times (n-1)}{2 \\times 2^{256}}\\right)\n\\end{align*}\\] Now if \\(n \\ll 2^{256}\\) we can again use the approximation \\(\\exp(x) \\approx 1 + x\\) to get the probability of a hash-collision as \\[\\begin{align*}\nP_{nc}(n) &\\approx 1 - \\frac{n \\times (n-1)}{2\\times 2^{256}}\\\\\n       & \\approx 1 - \\frac{n^2}{2\\times 2^{256}}\n\\end{align*}\\] Thus the probability of a hash-collision as a function of \\(n\\) is then approximately \\[\\begin{equation*}\nP_{c}(n) = \\frac{n^2}{2 \\times 2^{256}}\n\\end{equation*}\\] Thus to have a collision probability with \\(99.8%\\) you need ::: {.cell}\nsqrt(2*2^256*0.998)\n\n[1] 4.807505e+38\n\n::: which is about \\(5*10^{38}\\) hashes. To have a collision probability of \\(50 \\%\\) you need ::: {.cell}\nsqrt(2^256)\n\n[1] 3.402824e+38\n\n::: which amounts to \\(2^{128}\\) hashes. This is, of course a really big number.\nLet’s put this into perspective: If a computer computes \\(10000\\) hashes per second, it would take more than \\(10^{27}\\) years to compute \\(2^{128}\\) hashes. Narayanan et al. (2016) formulate it like this: “…if every computer ever made by humanity had been computing since the beginning of the universe, the odds that they would have found a collision by now are still infinitesimally small. So small that it it’s far less than the odds that a meteor will land on your house.”.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>First probability ideas and first steps in R</span>"
    ]
  },
  {
    "objectID": "01-lecture1.html#summary",
    "href": "01-lecture1.html#summary",
    "title": "1  First probability ideas and first steps in R",
    "section": "1.4 Summary",
    "text": "1.4 Summary\nIn this lecture we have taken a first step towards some very basic probability notions and some basic steps in R. Isn’t it amazing how much territory we could cover with so few concepts? You have learned about how to think probabilistically about collision probabilities and how to solve for them analytically, by simulation and for large numbers by approximation.\nWe have convinced ourselves using this knowledge only and taking on faith that the probability of independent events is the product of their individual probabilities, that the cryptographic Hash-function SHA-256, while it can produce collisions in theory, practically the number of hashes to make such a collision occur would be so large that we can be confident that hashing bit strings with SHA-256 gives us a unique fingerprint practically with certainty.\nThese are the basic probability concepts we have covered in this lecture:\n\nA random experiment: A process leading to an uncertain outcome.\nSample space: The collection of all possible outcomes of a random experiment.\nBasic outcome: A possible outcome of a random experiment.\nEvent: An event is a subset of basic outcomes. Any event which contains a single outcome is called a simple event.\nClassical probability find or make equally probably cases and the count them. The probability of an event \\(A\\) is the number of cases when \\(A\\) occurs divided by the total number of cases.\nRelative frequency probability defined as the number of times an event \\(A\\) occurs in a repeated number of trials divided by the total number of trials in a random experiment.\n\nThese are the R concepts we have covered in this lecture:\n\nobjects arbitrary names that can store different values and data types.\nfunctions ab R object that can accept other R objects as arguments, operate on them and return a new object.\nscripts files that store sequences of R commands and can be saved, repopened and allow the execution of commands.\nusing packages\nfinding help\nthe functions sample and replicate\n\nThese are the Applications we have covered in the lecture:\n\nConstructing a die on the computer and roll it an arbitrary number of times\nThe birthday problem and how to solve it analytically as well as through simulation\nExtrapolating the birthday problem to analyze cryptographic collision resistance of hash-functions by using ideas from probability",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>First probability ideas and first steps in R</span>"
    ]
  },
  {
    "objectID": "01-lecture1.html#project-1-craps-a-casion-dice-game.",
    "href": "01-lecture1.html#project-1-craps-a-casion-dice-game.",
    "title": "1  First probability ideas and first steps in R",
    "section": "1.5 Project 1: Craps: A casion dice game.",
    "text": "1.5 Project 1: Craps: A casion dice game.\nThe first project is about one of the very few dice games offered at a Casino: Craps.6\n6  This will be the only project in this course where we do not go into a direct financial application. Before we can do so, we need to build still a bit more knowledge of probability and skills in R.In Craps people throw a pair of dice and bet on outcomes of these throws. In this project we practice our new knowledge by implementing the dice throws of craps and the automatic summation of points on the computer. We try to find out the probability of the possible outcomes and check the fairness of the dice.\n\nYour first task in this project will be to write a function which allows you to virtually throw a pair of dice and sum up the points shown after the throw.\nSimulate and plot the result of your simulation using qplot() with the binwidth argument set to 1.\nAre these dice fair? Why?\nAssume the dice were unfair in the following sense: Numbers 1,2,3,4 and 5 have a probability of \\(1/8\\) while the 6 has a probability of \\(3/8\\). Study the help page of the samplefunction and find out how you could give these new probability weights to the function. If you redo your simulation analysis with the loaded dice, how does the picture change?\nWrite a script for this random experiment.\nNow look at the random experiment of throwing two dice with the concepts from probability theory: What is the sample space of this experiment. What are the probabilities of the basic outcomes? What is the probability of getting sum 7, what is the probability of getting sum 2 for the case of the fair dice, for the case of the unfair dice?\nImagine now that you are at the casino which uses fair dice and you can spend 150 Euro for chips. Since you have figured out that 7 is the most likely outcome you would like to buy bets on 7. The casino offers you a bet for 15 cent. When you win you get 1 Euro for the bet, when you loose you get nothing. Every bet costs 15 cents, so you can make 1000 bets in total on 7 from your budget of 150. Is this a good or a bad deal for you? Try to think about this problem in terms of a simulation.\n\n\n\n\n\nDiaconis, Persi, and Brian Skyrms. 2019. 10 Great Ideas about Chance. Princeton University Press.\n\n\nHealy, Kirean. 2019. Data Visualization: A Practical Introduction. Princeton University Press.\n\n\nNarayanan, Arvind, Joseph Bonneau, Edward Felten, Andrew Miller, and Steven Goldfeder. 2016. Bitcoin and Cryptocurrency Technologies: A Comprehensive Introduction. Princeton University Press.\n\n\nWickham, Hadley, and Garrett Grolemund. 2017. R for Data Science. O’Reilly. https://r4ds.had.co.nz/.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>First probability ideas and first steps in R</span>"
    ]
  },
  {
    "objectID": "01-lecture1_updated.html",
    "href": "01-lecture1_updated.html",
    "title": "1  First probability ideas and first steps in R",
    "section": "",
    "text": "1.1 Rolling a die: First Probability ideas.\nLets start with a classic and old example of a probability model, which occupied the attention of Pascal and Fermat as well as their gambling friend the Chevalier de Méré: Rolling a six sided die.\nWhen you role a die or several dice like shown in the following picture @ref(fig:dice), it is uncertain on which face it will finally end up after the throw.\nRolling dice: An old game of chance\nWhat seems clear though is, that it will turn out that it is either one of the six possible faces of the die.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>First probability ideas and first steps in R</span>"
    ]
  },
  {
    "objectID": "01-lecture1_updated.html#rolling-a-die",
    "href": "01-lecture1_updated.html#rolling-a-die",
    "title": "1  First probability ideas and first steps in R",
    "section": "",
    "text": "1.1.1 Random experiments, sample space, events\nIn the theory of probability a process leading to an uncertain outcome is called a random experiment. The example of throwing a die helps us to give a precise meaning to the notion of an uncertain outcome. While we can imagine in principle that the die lands on one of its corners and this is one outcome, we agree on the outset that we are going to consider the (practically relevant cases) that it will land on one of the faces.\nThe collection of all possible outcomes of a practical or conceptual random experiment is called in probability theory a sample space. While the sample space of throwing a die is an idealization it is exactly this idealization which simplifies the theory without affecting its applicability. The basic outcomes in the random experiment of throwing a die are that the die lands such that the upward showing face shows a 1 a 2, 3, 4, 5 or a 6. In the theory the collection of basic outcomes is denoted as a set. Thus the sample space of throwing a die is given as the set \\({\\cal S} = \\{1,2,3,4,5,6\\}\\).\nThe sample space \\({\\cal S}\\) is the set of all basic outcomes. The subsets of the sample space are often called events in probability theory. An event could be - for example - an outcome where the die shows an upward looking face with an even number \\(A = \\{2,4,6\\}\\).\n\n\n1.1.2 The role and nature of idealizations in applications\nIdealizations of the kind we discussed for the throw of a die are standard in probability and we will encounter them again and again. For example the movement of a stock price is often though of as a conceptual random experiment. When we try to agree on what is the appropriate sample space of this experiment, we can say that the price can not fall below 0 but it is hard to agree on what will be the highest possible price. In the probabilistic treatment of stock prices, which we will discuss later in our course, it is for instance common to assume that the sample space of this random experiment is the entire interval of non-negative real numbers \\({\\cal S} = [0, \\infty)\\).\nMany of us would hesitate to claim that the price might rise without bound. Yet many models in applied Finance are based on such an assumption. The models allow arbitrary price hikes but with arbitrary small probability as the price gets higher and higher. Practically it does not make sense to believe that a security price can become arbitrarily high. The use of arbitrarily small probabilities in a financial model might seem absurd but it does no practical harm and makes the model simple and convenient to use. Moreover, if we seriously introduced an upper bound on a security price at \\(x\\) it would be also awkward to assume that it is impossible that it could be just a cent higher, an assumption equally unappealing than assuming it can get in principle arbitrarily high.\n\n\n1.1.3 Classical Probability: Measuring uncertainty\nProbability is a measure of how likely an event of an experiment is. But how could we measure chance? Here is the first big idea of probability theory and how the originators thought about it.1 How do you measure anything? If you think of length, for example, you take an arbitrary standard you agree on and then count. The originators of probability theory pursued the same idea with chance: To measure probability you choose equally probable cases and then count.\n1 In this discussion I use chapter 1 in Diaconis and Skyrms (2019)The probability of an event \\(A\\) according to the originators of the theory of probability is then \\[\\begin{equation}\nP(A) = \\frac{\\text{Number of cases where $A$ occurs}}{\\text{Total number of cases}}\n\\end{equation}\\]\nThus, if we want to know the probability of the die ending up on a face such that an even number is shown (2,4,6) we have to compute according to this notion \\(3/6\\) (since the total number of cases are six basic outcomes) which is a chance of \\(50 \\%\\).\nNote that this classical notion of probability has a few interesting consequences, which we will discuss in more detail later but which already now naturally flow from this basic idea of measuring chance.\n\nProbability is never negative.\nIf an event \\(A\\) occurs in all cases \\(P(A)=1\\).\nIf \\(A\\) and \\(B\\) never occur in the same case, then \\(P(A \\,\\text{or}\\, B) = P(A) + P(B)\\).\n\nIn particular then the probability that an event does not occur is 1 less the probability that it occurs: \\(P(\\text{not}\\, A) = 1 - P(A)\\).\nLet us interrupt here our discussion of probability for a moment and ask how we can make good on our promise to make these ideas tangible, so we can play with them.\nFor this we will need the computer. Since we will talk to the computer in R, it is now the right time to look at the die rolling example from the perspective of R and dive into some of its basic concepts.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>First probability ideas and first steps in R</span>"
    ]
  },
  {
    "objectID": "01-lecture1_updated.html#rolling-die-on-computer",
    "href": "01-lecture1_updated.html#rolling-die-on-computer",
    "title": "1  First probability ideas and first steps in R",
    "section": "1.2 Rolling a die on the computer: First steps in R",
    "text": "1.2 Rolling a die on the computer: First steps in R\n\n1.2.1 The R User Interface\nBefore we can ask our tool to do anything for us, we need to know how to talk to it. In our case RStudio allows us to talk to our computer. It works like any other application. When you launch RStudio on your computer, in figure @ref(fig:rstudio-start-screen) you see a screen looking like this:\n\n\n\n\n\nThe RStudio startup screen\n\n\n\n\nIn this picture you see a screenshot of my RStudio screen. Interacting with the app is easy. You type commands via your keyboard at the prompt, which is the &gt; symbol. You find this symbol in the RStudio pane called Console. You can see it in the left pane in the screenshot. You send the command to the computer by pressing enter. After you have pressed enter, RStudio sends the command to R and displays the result of your command with a new prompt to enter new commands, like this:\n\n1+1\n\n[1] 2\n\n\nLet me pause to explain what you see here in this code example. First you see a light-gray box containing the command 1+1. This is an instance of a so called code chunk. Moving the cursor to the right upper corner of the chunk, will display a copy icon and you can click this icon to copy the code to the computer’s clipboard and then paste it at the prompt of your console (or for that matter anywhere else) and run it in R studio, if you wish. In the code-chunk the R-prompt &gt; is not displayed. This symbol of the prompt is only shown in the Console itself.\nWhen the code is executed, you see the result in the second light-gray box, just below the first one. It starts with a double hash ##, indicating that it shows an output of running the above code chunk and then displays the output as it would appear in the command window [1] 2.\nThe [1] means that the line begins with the first value of your result. For example, if you enter the command 20:60 at the prompt of your console which means in the R language, “list all the integers from 20 to 60” and press enter you get:\n\n20:60\n\n [1] 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44\n[26] 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60\n\n\nmeaning that 20 is the first value displayed in your result. Then there is a line break because not all values can be displayed on the same line and R tells you that 45 is the 26-th value of the result.\nThe colon operator : is a very useful function in R which we will need often. It allows us to create sequences of every integer between two given integers.\nR needs a complete command to be able to execute it, when the return key is pressed. Lets see what happens, if a command is incomplete, like for instance &gt; 5*.\nIn this case R will show the expression followed by a + instead of showing a new prompt. This means that the expression is incomplete. It expects more input. If we complete the expression, say like\n&gt; 5*\n+ 4\nthe expression can be evaluated and a new prompt is shown in the console.\nIf you type a command that R does not understand, you will be returned an error message. Don’t worry if you see an error message. It just is a way the computer tells you that he does not understand what you want him to do.\nFor instance, if you type 5%3 you will get an error message like this\n&gt; 5%3\nError: unexpected input in \"5%3\"\n&gt;\nSometimes it is obvious why a mistake occurred. In this case, that R just does not know what to do with the symbol %. It has no meaning in this context. Sometimes it is not so obvious what the error message actually means and what you might do about it.\nA useful strategy in this case is to type the error message into a search engine and see what you can find. The chance is very high that others encountered the same problem before you and got helpful advice how to fix it from other users on the internet. One site, we find particularly helpful for all kinds of questions related to R and R programming is https://stackoverflow.com/. Try it at the next opportunity.\nNow with this basic knowledge, we can already make the first step to create a die on the computer using R. If you think of a physical die, the essential thing that matters are the points on its six sides. If you throw the die it will usually land on one of these sides and the upward showing side of the die shows the number of points. The colon operator : gives us a way to create a group of numbers from 1 to 6. R gives us the result as a one dimensional set of numbers.\n\n1:6\n\n[1] 1 2 3 4 5 6\n\n\nLets use these first steps in R to recap the probability concepts we have learned using this example of the six sided die: A basic outcome of rolling a six-sided die is for example 6 if the upper side after rolling the die happens to be the side with 6 points. The sample space of the experiment of rolling a six-sided die is the set \\({\\cal S} = \\{1,2,3,4,5,6\\}\\). In probability theory we often use the symbol \\({\\cal S}\\) or \\(S\\) for sample space. In many probability texts the sample space is also often denoted by the symbol \\(\\Omega\\) the Greek letter for (big) Omega. A random experiment in this example is the rolling of the die. The outcome is uncertain but once the die is rolled the outcome can be determined precisely. The event that the outcome is a display of 10 points is the empty set \\(A = \\emptyset\\). The symbol \\(\\emptyset\\) comes from set theory and means the set containing no elements. This event can contain no elements because we can not get a score of 10 by rolling a six sided die.\n\n\n1.2.2 Objects\nYou can save data in R by storing them in objects. An object is a name, you can choose yourself to store data. For example, if you choose to store the value 6 in an object called point_six, you would type:\n\npoint_six &lt;- 6\n\nat the prompt. R will the store the value 6 in the object called point_six, which you can use to refer to the value. If you type the name of your object at the prompt, R will display the value you have assigned. A useful key combination for typing the assignment operator &lt;- is to use the key combination ALT _. At the R prompt R will automatically print an assignment operator.\nNow if you type the name of the object and press enter, R will display the value or values stored in it, like this:\n\npoint_six\n\n[1] 6\n\n\nNow you can use the name of the object to refer to its value. For instance, you could divide point_sixby 2and get a meaningful result\n\npoint_six/2\n\n[1] 3\n\n\nNow to make our die more tangible and useful, let us store it in an R object by typing the following command at the prompt. This command creates an object with name die and assigns the vector 1,2,3,4,5, 6 to it.\n\ndie &lt;- 1:6\n\n\n\n\n\n\nThe RStudio Environment pane keeps track of the objects you have created\n\n\n\n\nYou can now see in the right upper Environment pane in figure @ref(fig:rstudio-screen-with-command) that R shows you that there is an object with the name die that it consists of integers 1,2,3,4,5. As you create more objects they will be stored in the Environment pane and are ready for your reference, unless you delete them. You can remove or delete an object by typing rm(object) or by assigning the value die &lt;- NULL which would also remove the object from your environment or workspace.\nYou can name your objects almost anything with a few exceptions. An object name must not start with a number. There are some special symbols which can also not be used in object names, like ^, !, $, @, +, -, /, *. Note that R is case sensitive and distinguishes small and big letters. If you assign a new value for an object you have already created, R will overwrite the object without warning.\nYou can see which objects are currently created and available for you in the Environment pane of your session of by typing ls(). The UNIX users among you will recognize this command from the unix shell, where it displays the files in a directory.\nBefore we learn how we can actually roll our die and perform a random experiment with it, let us briefly use the opportunity to explain a few things about how R does computations. We have already explained that we can use the object name to refer to the value. So for instance if we type\n\ndie*die\n\n[1]  1  4  9 16 25 36\n\n\nThis might irritate some of you because we have called the object a vector. In linear algebra multiplication of vectors is only allowed if there is an inner product. What happens here, if we use * the multiplication operator is that R does an element-wise multiplication of the six numbers of our die. Of course R allows to take an inner product as well, but this needs a different operator. To compute an inner product, we would type\n\ndie %*% die\n\n     [,1]\n[1,]   91\n\n\nNow R displays the result as a vectors with one row and one column, which is denoted in the output by [ , 1] for the column and [1, ] for the row. We will learn later more about the use and the meaning of this notation in R.\nThe element wise execution R usually uses also means that when you, for example type\n\ndie - 1\n\n[1] 0 1 2 3 4 5\n\n\nR would subtract 1 from every component in the vector die.\nAnother specific behavior of R, you need to know about is called recycling. If you give R two vectors of different length in an operation, R will repeat the shorter vector as long as it is of equal length with the longer one. For example, if you have: ::: {.cell}\ndie + 1:2\n\n[1] 2 4 4 6 6 8\n\n:::\nyou see that R adds 1 to 1 and 2 to 2 and then starts over again by adding 1 to 3 and 2 to 4 and then starts over once again by adding 1 to 5 and 2 to 6. If the longer vectors is not a multiple of the shorter one, R recycles but the cuts off. It will give you a warning though. ::: {.cell}\ndie + 1:4\n\nWarning in die + 1:4: longer object length is not a multiple of shorter object\nlength\n\n\n[1] 2 4 6 8 6 8\n\n:::\nWhile this might seem awkward to some of you, we will see that for data manipulation element-wise execution is often extremely useful. It allows to manipulate groups of values in a systematic yet easy way.\n\n\n1.2.3 Functions\nR contains many functions which we can use to manipulate data and compute things. The syntax for using a function is very simple: You type the function name and put the value of the function argument in parentheses. Here we use for illustrations the function of the square root sqrt(): ::: {.cell}\nsqrt(4)\n\n[1] 2\n\n::: or rounding a number: ::: {.cell}\nround(3.1415)\n\n[1] 3\n\n::: The data you write in the parentheses are called the function arguments. Arguments can be all sorts of things: raw data, R objects, results from other functions.\nIf functions are nested, R evaluates the innermost function first and then goes on to the outer functions. To see examples of all these instances you can take ::: {.cell}\nmean(1:6)\n\n[1] 3.5\n\nmean(die)\n\n[1] 3.5\n\nround(mean(die))\n\n[1] 4\n\n::: for example.\nFor simulating random experiments, R has the very useful function sample(). With this function we can roll our die on the computer and conduct actual random experiments.\nThe function takes as arguments a vector names x and a number named size. sample will return size elements randomly chosen from the vector x. Lets say: ::: {.cell}\nsample(x = 1:4, size = 2)\n\n[1] 3 1\n\n:::\nIn this case sample has chosen 4,1 from the vector x = (1,2,3,4) at random.\nIf we want to roll the die in our computer we can thus pass the die as an argument to sample and use the number 1 for the size argument. Lets do a few rolls with our die ::: {.cell}\nsample(x = die, size = 1)\n\n[1] 3\n\nsample(x = die, size = 1)\n\n[1] 1\n\nsample(x = die, size = 1)\n\n[1] 2\n\nsample(x = die, size = 1)\n\n[1] 1\n\n::: These are the random outcomes of our consecutive rolls. It is as if we had thrown an actual die but in this case we have done the same thing on the computer. Isn’t it cool that this is possible at all? The sample() function will remain our good friend throughout this course.\nR functions can have many arguments, but they need to be separated by a comma.\nEvery argument in every function has a name. We specify which data are assigned to the arguments by setting a mathematical equal sign = between the name and the data. Names help us to avoid passing the wrong data and thereby mixing up things or committing errors. But using names is not necessary. If we just wrote ::: {.cell}\nsample(die,1)\n\n[1] 4\n\n::: R would also know what to do. It is not always clear which names to use for a function. If you are not sure, you can use the function args() to look it up. Here we take the function roundas one example. ::: {.cell}\nargs(round)\n\nfunction (x, digits = 0, ...) \nNULL\n\n::: Note that the digits argument in the round function is already set to 0. Frequently R functions come with optional arguments. These arguments are optional because the come with a default value, which is 0 in case of the round function.\nWe recommend that you write out argument names as a rule. It gives clearer code and avoids errors. If you don’t write argument names, R matches your values to the arguments of the function by order.\n\n\n1.2.4 Writing your own functions\nNow we are ready to write our own function to roll the die in our computer. Each function in R has the same elements: A name, a function body of code and a set of arguments. To write your own function, you have to write up all of these parts and save them in an R object. The syntax is:\nmy_function &lt;- function() {}\n\nThe name here is my_function, next comes the expression function() which needs to be assigned. The names of the function arguments have to be written between the parentheses. Then we have to write the actual code within the braces {}.\nTo do this for the die, lets write a function named roll_die. ::: {.cell}\nroll_die &lt;- function(){die &lt;- 1:6 \n                         sample(die, size = 1)}\n:::\nNow we can roll our die for a few times to show how the function works ::: {.cell}\nroll_die()\n\n[1] 5\n\nroll_die()\n\n[1] 4\n\nroll_die()\n\n[1] 2\n\nroll_die()\n\n[1] 6\n\nroll_die()\n\n[1] 1\n\n::: Note that in our function roll_die() has no arguments, just the function body. This is perfectly legitimate in R. It is important that when we call the function we have to call it with the parenthesis like roll_die(). If we only call the name roll_die, R will display the code in the function body.\nA final remark in the sample function is in place here. If we look at the arguments of sample using the args function we see ::: {.cell}\nargs(sample)\n\nfunction (x, size, replace = FALSE, prob = NULL) \nNULL\n\n::: Lets do not discuss all the details of this output but concentrate for a moment on the replace argument. What does this mean?\nAs we saw previously we can use the sample function to model the rolling of our die. If we set the size argument to 1 we get the roll of one die. If we set the size argument to n, we would simulate the rolling of n dies. But now the replace argument becomes crucial. As we can see in the output of the args function replace has a default value FALSE. This is a logical argument. It tells R, for example, that if we set size = 2, meaning that two dice are rolled, if the first dice shows, say a value of 3, the second die cannot show 3 as well.\nThis is clearly not what we have in mind when we model the rolling of 2 dice. It should be possible that both dies show the same value. To enable this behavior of the sample function, we have to change the default value of the replace argument to TRUE. Then R chooses a random draw from all of the six possible values for all dice rolled.\nCongratulations ! You have written your first R function for conducting a simple random experiment. Let me remind you once again: Think of the parentheses as a trigger that tells R to run the function. If you omit the trigger R just prints the body of the function. When you run a function, all the code in the function body is executed and R returns the result of the last line of code. If the last line of code does not return a value neither will R.\n\n\n1.2.5 Arguments\nImagine we remove the first line of code in our function body and changed the name die in the sample function to “ball”. ::: {.cell}\nroll_die2 &lt;- function(){sample(ball, size = 1)}\n::: If we call the function now, we will get an error. The function call roll_die2() will result in the error message Error in sample(ball, size = 1) : object 'ball' not found (try it!)\nWe could supply ball when we call roll_die2 if we make ball an argument of the function. Lets do this: ::: {.cell}\nroll_die2 &lt;- function(ball){sample(ball, size = 1)}\n::: Now the function will work as long as we supply ball when we call the function. ::: {.cell}\nroll_die2(ball = 1:6)\n\n[1] 1\n\n::: Note that we still get an error, if we forget to supply ball argument. This could be avoided if we give the function a default argument ::: {.cell}\nroll_die2 &lt;- function(ball= 1:6){sample(ball, size = 1)}\n::: Now if we type: ::: {.cell}\nroll_die2()\n\n[1] 6\n\n::: everything works, just as intended.\n\n\n1.2.6 Scripts\nSo far we have worked by interacting with the console. But what if you want to edit your functions? It would be much easier, if you could use a draft of your code and work form there. This can be done by using a script.\nYou create a script by going to File &gt; New File &gt; R script in the menu bar of RStudio. Using scripts is the standard way to write code in R. It not only helps you to keep track of your code, save it and edit it later. It also makes your work reproducible. You can edit and proofread your code and share it with others. To save your script go to File &gt; Save As in the menu bar.\n\n\n\n\n\nThe RStudio Script\n\n\n\n\nRStudio has many useful features to help you work with scripts. You can for instance automatically execute a line in a code by using the run button. You can also execute sections of code or the entire script. The entire script is executed by running the Source button. For all these commands there are key short cuts which you will learn as you work more with RStudio and R.\nFrom now on you should write all your R-code for this course in scripts. Make a new folder for the scripts you write and store your R-code there from now on.\n\n\n1.2.7 Using packages and finding Help\nWe have now a function which we can use to simulate the rolling of a die, roll_die(). If the die is fair it should be the case that if we roll the die often, all numbers should occur about equally often. The die should not be weighted in favor of a particular value.\nOne way to learn whether our die is fair are repetition and visualization. These are tools we will need all the time, when working with data and when doing probability. While R has many useful functions, one of the great powers is that R is constantly extended by a huge community of users by providing packages.\nPackages are add on functions, which will not be available when you install R. They need to be installed and loaded before you can use them. Since packages are such a powerful tool in R we need to introduce what they are and how to use them in the beginning.\n\n\n1.2.8 Packages\nThere are many visualization tools in R that come with the basic installation. Since the point we want to make here is about packages, we will use a visualization function which is part of the add on package ggplot2, a very popular package for making all kinds of graphs. ggplot2 is not part of the base-R distribution. It has to be therefore loaded before we can use it.\nThere are many additional functions provided with this package. Indeed you could run a whole course on just that 2 For the point we want to make here we will use just one of them, called qplot(), a shorthand for for quick plot.\n2 A very good starting point is for instance Healy (2019), in case you are interested. Also a good source is the first chapter in Wickham and Grolemund (2017).Since qplot() is a function in the package ggplot2, we first need to install this package. To install a package you need to be connected to the internet. If you have internet connection go to the command line and run at the command line: install.packages(\"ggplot2\").\nR displays what is happening while executing the command. Don’t worry if you don not know what all of these messages exactly mean and don’t panic that they are displayed in red. All packages can be installed like this. You have just to enter the correct name in the function install.packages(). The lower right pane in the RStudio software alternatively provides a tab called Packages. Using this tab, you can also install R packages interactively by clicking the install button on the upper left corner of the Packages tab.\nAfter installation the package is on our hard-drive but it can not yet be used. To use the package it has to be loaded. This is done with the command library. To load the ggplot2 package we type ::: {.cell}\nlibrary(\"ggplot2\")\n::: and hit the return key. Many things could be said about the R package system and you will learn it in more detail as we go along in our course. For the moment the most important thing to remember is that a package needs to be newly loaded whenever you want to use it in a new R session.\nTo check whether our dies is fair, we need to roll it many times. R provides a function, that does this for us. This function is called replicate() and provides an easy way to repeat a command many times. The number of times we want to repeat something is given as an argument to the replicate function.\nNow lets roll our die 100 times and save the result in an object we call rolls: ::: {.cell}\nrolls &lt;- replicate(100, roll_die())\n::: We now use the qplot()function from the ggplot2 library to make a quick visualization, by typing the command qplot(rolls). I include the resulting picture in the following figure ::: {.cell layout-align=“center”} ::: {.cell-output-display}  ::: ::: If you try this and your picture looks a bit different from mine, don’t worry. This is as things should be. I have stored the picture after one particular run of the replicate function and saved it in my figures folder to these lecture notes. Each time you run the replicate function anew a new random outcome is stored which will look not exactly the same as any other or course. This is what randomness does to the outcome of rolling a die.\nIt looks like every value occurred roughly 16 times but there is still quite some variation. For instance, the value 3 seems to occur more than 20 times whereas the value 2 occurs less than 15 times.\nMaybe we have to give it another trial with more replications. With the computer we can do this with a fingertip. Let us roll our die 10000 times and plot the result.\n&gt; rolls2 &lt;- replicate(10000, roll_die())\n&gt; qplot(rolls2m bindwidth = 1)\nNow the picture looks better.\n\n\n\n\n\nFrequencies of 1, 2, 3, 4, 5, 6 after rolling our virtual die 10000 times\n\n\n\n\nWe will learn in our course why the picture get better as we increase the number of rolls of the die. For the moment, let us just state that at least for this case it seems that there is no significant visual evidence that our virtual die is loaded.\n\n\n1.2.9 Getting Help\nWe have now learned a tiny number of R functions and we have written one function ourselves. We have learned how to make use of functions provided by packages.\nIt would be overwhelming to memorize and learn them all. In R, fortunately, every function comes with a detailed documentation and with its own help page. You need to learn how to use this source right from the beginning.\nTo access the help page of a function you type the function name preceded by a question mark at the prompt, like this ::: {.cell}\n?sample\n:::\nThen, after you have pressed the return key, a help page is opened in the right lower pane under the help tab as shown in @ref(fig:helpinr) ::: {.cell layout-align=“center”} ::: {.cell-output-display}  ::: :::\nThis help page has a particular structure that you will find for every other R function no matter whether it is provided by the base installation or by a package. In the upper left corner you see the name of the function (sample) and in curly brackets next to it the term base, which means that this is a function in the R base installation. Then you see a headline about what the function does.\nFrom the top of the page, you then first see the field Description. This is a short description what the function does. Here it says\nDescription\nsample takes a sample of the specified size from the elements of x using either with or without replacement.\nThe next field is Usage. It gives you the function description with the arguments. Here for example\nUsage\nsample(x, size, replace = FALSE, prob = NULL)\n\nsample.int(n, size = n, replace = FALSE, prob = NULL,\n           useHash = (!replace && is.null(prob) && size &lt;= n/2 && n &gt; 1e7))\n           \nThe first line in Usage should by now be familiar. Don’t worry about the second line. The function can obviously do more than we know so far.\nNext comes a list of arguments the function takes and what type of information R expects you to provide, as well as what R will do with this information. Here it says for example\nArguments\nx   \neither a vector of one or more elements from which to choose, or a positive integer. See ‘Details.’\n\nn   \na positive number, the number of items to choose from. See ‘Details.’\n\nsize    \na non-negative integer giving the number of items to choose.\n\nreplace \nshould sampling be with replacement?\n\nprob    \na vector of probability weights for obtaining the elements of the vector being sampled.\n\n...\n\nWe omit some information here.\nThen comes a field called Details which gives a more in-depth description of the function. The next field is called Value. It describes what the function returns when you run it. Then we have a reference to related R functions under the field See. Finally there is a field called Examples. This field contains example code that is guaranteed to work. It shows a couple of different cases how you can use the function in practice.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>First probability ideas and first steps in R</span>"
    ]
  },
  {
    "objectID": "01-lecture1_updated.html#coincidences",
    "href": "01-lecture1_updated.html#coincidences",
    "title": "1  First probability ideas and first steps in R",
    "section": "1.3 Application: Coincidences and the Blockchain",
    "text": "1.3 Application: Coincidences and the Blockchain\n\n1.3.1 The birthday problem\nWe learned now some basic notions of probability and of R with the example of the rolling of a fair die. It is really surprising what already can be done by just applying the simple ideas we have just learned. The application we want to show you now is known to probability theorists as the birthday problem. It originates in a piece of recreational maths and math-puzzles but it reaches out until cryptography, computer security and blockchain architecture. It also gives us an opportunity to apply some of our newly acquired R-knowledge.\nThe starting question in the birthday puzzle is: What is the probability that at least two people in a room share the same birthday, when we neglect things like leap years, and when we assume that birthdays on any day of the year are equiprobable and the birthdays of the people in the room are independent. We have no twins for example. Perhaps some of you have already seen this problem before. If not, the result may surprise you. Even if you saw the birthday problem before, perhaps not many of you have seen the connection to the cryptography and the blockchain.3\n3 We follow here the discussion in Diaconis and Skyrms (2019)First, observe that we took our assumptions such that we are in the frame of classical probability like the originators of the field thought about it.\nNow for the sake of familiarizing ourselves with the new concepts, let us try to map the birthday problem into the probability notions we learned so far.\nThe sample space is the set of possible outcomes of the experiment. Assume we have \\(n\\) people in the room. Since each person can have a birthday at any of the 365 days in the year (note that we assumed we exclude leap years) and we have \\(n\\) people in the room, the possible basic outcomes are \\(365 \\times 365 \\times 365 \\cdots 365\\) taken \\(n\\) times. This will produce a set with \\(365^{n}\\) ordered \\(n-tuples\\) or sequences of birthdays. This is the sample space of this experiment, written as \\({\\cal S} = \\{x | x \\in 365^n\\}\\) in set theoretic notation. It means the sample space is the set of all ordered \\(n-tuples\\) from the Cartesian product \\(365^n\\).\nRemember that in mathematics, a Cartesian product is a mathematical operation that returns a set (or product set or simply product) from multiple sets (in this case the sample space, \\({\\cal S}\\). That is, for sets \\(A\\) and \\(B\\), the Cartesian product \\(A \\times B\\) is the set of all ordered pairs \\((a, b)\\) where \\(a \\in A\\) and \\(b \\in B\\).\nNow given this sample space we can assign a probability to the event that two people chosen at random will have the same birthday. The denominator will this be \\(365^n\\). The nominator for this probability will be much more straightforward to figure out, if we compute the complement. We discussed before that the probability of the complement of an event is 1 minus the probability of the event. Translated to the birthday problem, this means we look for the 1 minus the probability that that all birthdays are different. The probability that the second person has a different birthday from the first is \\(\\frac{364}{365}\\). If they are different the probability that the third person has a different birthday from them is \\(\\frac{363}{365}\\) and so on for all \\(n\\) in the room. Thus the probability of a shared birthday in the room is: \\[\\begin{equation*}\nP(\\text{at least two people share birthday}) =\n1 - \\frac{365 \\times 364 \\times 363 \\cdots \\times 365 - n +1}{365^n}\n\\end{equation*}\\] Now there is an additional thing we did not yet introduce and which we will learn about in the next lecture. This refers to our assumption that the individual birthdays are independent. For the moment you need to take the following fact on faith: The probability of independent events is the product of the probability these events.\nNow comes the surprise for those of you who did not already see the birthday problem. Assume the group size of people is 23. Let us compute the birthday coincidence probability. For this computation we make use of the R function prod() which takes a vector of numbers as input and computes their product. For \\(n=23\\) we need the list of numbers from 365 to 343. Now we can use the : operator and take advantage from one of its cool properties. If we formulate the command as 365:343 then the colon operator will give us a descending list of integers starting at 365 and ending at 343. Then the probability can be computed as ::: {.cell}\n1 - prod(365:343)/365^23\n\n[1] 0.5072972\n\n::: We have used the operator ^ which is needed to compute powers. Now we see from our computation that with 23 people the probability is already larger than 50 %. Quite stunning. You can now verify yourself that with 50 people this probability is already at 97 %.\n\n\n1.3.2 An R function to compute birthday probabilities\nNow let us use our knowledge about how to write R functions to write a function to compute birthday probabilities. The function argument is the number \\(n\\) of people in class. The coincidence probability is given by the formula we have derived. Now here is how we could go about writing this function: ::: {.cell}\nbirthday_collisions &lt;- function(n){\n  1 - prod(365:(365-n+1))/365^n\n}\n::: Now lets verify what I have claimed before about the group size 50. ::: {.cell}\nbirthday_collisions(50)\n\n[1] 0.9703736\n\n::: Voila, indeed with 50 people in the group the collision probability is already at 97 %.\n\n\n1.3.3 Determining birthday collisions by simulation\nNow this was an argument derived analytically and then we just packed the derived result into a function to compute the exact birthday-collision probabilities. Here is how we could figure out these probabilities by simulation, even with the minimal tools we have learned so far.\nLet us simulate first birthdays for 23 people in a room using the sample function. We stick to the assumption that our year has 365 days (no leap years), and that all birthdays are equally likely, so we can sample from the list of days from 1 to 365 with the sample function which we have already encountered.\nWe need to take care to set the replace argument in the sample function to the value TRUE. This is because we always draw for every person in the room from the same list of values. If one birthday is drawn it is possible in principle that later in the process the same birthday is drawn again. Before, when we worked with only one die we did not need to care whether sample drew with replacement or not. ::: {.cell}\nb_23 &lt;- sample(1:365, 23, replace = TRUE)\n::: This little piece of code is to be read in the same way as before when we built the process of rolling a die on the computer. We sample 23 values from the vector \\(1,2,3,\\cdots,365\\) without replacement. Think about a situation where I use uniform random numbers to call 23 people in your group and write the birthdays I get in this way into the object b_23.\nHere is how I can find the number of matches in b_23. R has a built in function, which is called unique(). So if there were two people with the same birthday in b_23, applying unique() to b_23 would only keep one value. Now clearly if we subtract the length of the resulting object from 23 we get the number of collisions in b_23. Fortunately we can use the R function length() to achieve this task. length() computes the length of any object we give it as an argument. ::: {.cell}\nm_23 &lt;- 23 - length(unique(b_23))\n::: So for instance if sample() drew 23 different birthdays m_23 would be 0.\nLet’s pack this process into a function: ::: {.cell}\nsim_23 &lt;- function(){\n  b_23 &lt;- sample(1:365, 23, replace = TRUE)\n  (23 - length(unique(b_23)))\n}\n::: Now we can repeat this process many times - say 10000 times - using the replicate function. ::: {.cell}\nsimprobs_23 &lt;- replicate(10000, sim_23())\n:::\nNow how do we get from here to probabilities? Here we anticipate and introduce a new probability concept which we will discuss in more detail in the next lecture but which you perhaps already came across a few times.\nThis concept could be called the relative frequency probability . In this concept the probability of an event \\(A\\) is defined as \\[\\begin{equation*}\nP(A) = \\frac{\\text{Number of times $A$ occurs in repeated identical trials}}{\\text{Total number of trials in a random experiment}}\n\\end{equation*}\\] Applying this concept to our data generated by the replicate function and stored in b_23 would require two things. First we would have to count the number of times we saw a 1,2 or more matches, which in our case means 1,2 or more birthday collisions, add up the count and divide by the number of replications. Clearly it is also easier here to work the other way round. We count the number of no collisions and use the complement rule, by computing 1 minus the relative frequency of no collisions. Let us do that.\nNow this is clearly too tedious to do by hand. We will discuss systematically in the next lecture how to refer to individual values in an R object and select and operate on ranges of values etc.\nFor the moment, look at the next step just as a piece of magic and don’t worry if you do not exactly understand the syntax at the moment.\nIn the numerator I ask R to count the number of 0s (no birthday collisions) in the object simprobs_23 and then I divide it by 10000, just as in the definition of relative frequency probability. Then I compute 1 minus this relative frequency ::: {.cell}\n1 - length((simprobs_23[simprobs_23 == 0]))/10000\n\n[1] 0.5067\n\n::: Voila, this is pretty good, isn’t it? Remember that the analytical solution we just got a bit earlier was 0.5072972\nIsn’t this cool? Instead of using formal reasoning we built a random experiment on the computer and came up with a pretty good approximation of the collision probability.\nLet’s check the result with 50 for the sake of completeness and for the sake of practice, with an experiment with 10000 trials. I now stitch all steps together. ::: {.cell}\nsim_50 &lt;- function(){\n  b_50 &lt;- sample(1:365, 50, replace = TRUE)\n  (50 - length(unique(b_50)))}\n\nsimprobs_50 &lt;- replicate(100000, sim_50())\n1 - length((simprobs_50[simprobs_50 == 0]))/100000\n\n[1] 0.97027\n\n::: Pretty amazing! Before we got the exact value as 0.9703736.\nBut now let us stay still with the birthday problem but now get away from this playful application to something really serious: Cryptography.\n\n\n1.3.4 Hash-functions and the blockchain\nThe birthday problem is the canonical model for the probabilistic study of coincidences of all kinds. A particular important application of this idea is in cryptography, and its concept of so called hash-functions.\nA hash-function maps a string of arbitrary but finite length to a fixed length string of output.4 A very frequently used hash-function in practice is the function SHA-256, which maps its input to a string of 256 bits5. So, you could for instance give the text of these lecture notes as an input to SHA-256 and it would map this into a 256-bit string, which functions like a finger print of this text. This function is an instance of a special from of mappings called a one-way-function meaning that it is easy to evaluate or compute but it is practically impossible to learn from the value the initial argument by computing the inverse.\n4 We have taken this discussion from https://brilliant.org/wiki/birthday-paradox/5 A bit, short for binary digit, is defined as the most basic unit of data in telecommunications and computing. Each bit is represented by either a 1 or a 0Hash-Functions are key pillars of modern cryptography, where they play a major role in message authentication. This is because it is impossible to modify the input without significantly changing the output. So in our previous example, if you only deleted or added a comma to these notes and hash-them again they would hash into a completely different value than the previous version which still was without this minor change. Comparing the hash-values would reveal immediately that something has changed.\nThe collision problem for hash-functions is formally equivalent to the birthday problem. The event we are interested in is that at least two input strings hash-to the same value. Again it is easier to think about the complementary event that all inputs hash to a different value.\nIf the range of the hash-function is \\(M\\) and the hash-function maps into a 256 bit string then there are \\(2^{256}\\) basic outcomes. Since the hash-function maps a large string onto a smaller string it is possible that there are two different strings \\(x \\neq y\\) mapping to the same value \\(\\text{hash}(x)=\\text{hash}(y)\\). This would be a problem for message authentication because it would give the same “fingerprint” for two different strings.\nFor a cryptographically secure hash function it is therefore required that the probability of such a collision should be small enough to exclude a collision in all practically relevant circumstances.\nNote that this is a problem formally similar to the birthday problem. In the cryptography context we ask, how many values does a potential attacker have to hash through SHA-256 before the probability of a collision is larger than a certain threshold?\nThe probability of no-collision (\\(nc\\)) with \\(n\\) hashed-messages through a SHA-256 hash function is \\[\\begin{equation*}\nP_{nc}(n) = 1 \\times \\left(1 - \\frac{1}{2^{256}}\\right)\\times\n\\left(1 - \\frac{2}{2^{256}}\\right) \\times \\cdots \\times \\left(1 - \\frac{(n-1)}{2^{256}}\\right)\n\\end{equation*}\\]\nNow to do the estimation of the threshold we use an approximation, which works with a simple property of the logarithm: \\(\\log(1-x)\\approx -x\\) when \\(x\\) is small. Thus for \\(n\\) much smaller than \\(M\\), or \\(n \\ll M\\), we can write the no-collision probability approximately as \\[\\begin{align*}\nP_{nc}(n) &\\approx 1 \\times \\exp\\left(-\\frac{1}{2^{256}}\\right) \\times \\exp\\left(-\\frac{2}{2^{256}}\\right) \\times \\cdots\n\\times \\exp\\left(-\\frac{(n-1)}{2^{256}}\\right) \\\\\n&\\approx 1 \\times \\exp\\left(-\\frac{(1+2+3+...+(n-1))}{2^{256}} \\right) \\\\\n&\\approx \\exp\\left(-\\frac{n \\times (n-1)}{2 \\times 2^{256}}\\right)\n\\end{align*}\\] Now if \\(n \\ll 2^{256}\\) we can again use the approximation \\(\\exp(x) \\approx 1 + x\\) to get the probability of a hash-collision as \\[\\begin{align*}\nP_{nc}(n) &\\approx 1 - \\frac{n \\times (n-1)}{2\\times 2^{256}}\\\\\n       & \\approx 1 - \\frac{n^2}{2\\times 2^{256}}\n\\end{align*}\\] Thus the probability of a hash-collision as a function of \\(n\\) is then approximately \\[\\begin{equation*}\nP_{c}(n) = \\frac{n^2}{2 \\times 2^{256}}\n\\end{equation*}\\] Thus to have a collision probability with \\(99.8%\\) you need ::: {.cell}\nsqrt(2*2^256*0.998)\n\n[1] 4.807505e+38\n\n::: which is about \\(5*10^{38}\\) hashes. To have a collision probability of \\(50 \\%\\) you need ::: {.cell}\nsqrt(2^256)\n\n[1] 3.402824e+38\n\n::: which amounts to \\(2^{128}\\) hashes. This is, of course a really big number.\nLet’s put this into perspective: If a computer computes \\(10000\\) hashes per second, it would take more than \\(10^{27}\\) years to compute \\(2^{128}\\) hashes. Narayanan et al. (2016) formulate it like this: “…if every computer ever made by humanity had been computing since the beginning of the universe, the odds that they would have found a collision by now are still infinitesimally small. So small that it it’s far less than the odds that a meteor will land on your house.”.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>First probability ideas and first steps in R</span>"
    ]
  },
  {
    "objectID": "01-lecture1_updated.html#summary",
    "href": "01-lecture1_updated.html#summary",
    "title": "1  First probability ideas and first steps in R",
    "section": "1.4 Summary",
    "text": "1.4 Summary\nIn this lecture we have taken a first step towards some very basic probability notions and some basic steps in R. Isn’t it amazing how much territory we could cover with so few concepts? You have learned about how to think probabilistically about collision probabilities and how to solve for them analytically, by simulation and for large numbers by approximation.\nWe have convinced ourselves using this knowledge only and taking on faith that the probability of independent events is the product of their individual probabilities, that the cryptographic Hash-function SHA-256, while it can produce collisions in theory, practically the number of hashes to make such a collision occur would be so large that we can be confident that hashing bit strings with SHA-256 gives us a unique fingerprint practically with certainty.\nThese are the basic probability concepts we have covered in this lecture:\n\nA random experiment: A process leading to an uncertain outcome.\nSample space: The collection of all possible outcomes of a random experiment.\nBasic outcome: A possible outcome of a random experiment.\nEvent: An event is a subset of basic outcomes. Any event which contains a single outcome is called a simple event.\nClassical probability find or make equally probably cases and the count them. The probability of an event \\(A\\) is the number of cases when \\(A\\) occurs divided by the total number of cases.\nRelative frequency probability defined as the number of times an event \\(A\\) occurs in a repeated number of trials divided by the total number of trials in a random experiment.\n\nThese are the R concepts we have covered in this lecture:\n\nobjects arbitrary names that can store different values and data types.\nfunctions ab R object that can accept other R objects as arguments, operate on them and return a new object.\nscripts files that store sequences of R commands and can be saved, repopened and allow the execution of commands.\nusing packages\nfinding help\nthe functions sample and replicate\n\nThese are the Applications we have covered in the lecture:\n\nConstructing a die on the computer and roll it an arbitrary number of times\nThe birthday problem and how to solve it analytically as well as through simulation\nExtrapolating the birthday problem to analyze cryptographic collision resistance of hash-functions by using ideas from probability",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>First probability ideas and first steps in R</span>"
    ]
  },
  {
    "objectID": "01-lecture1_updated.html#project-1-craps-a-casion-dice-game.",
    "href": "01-lecture1_updated.html#project-1-craps-a-casion-dice-game.",
    "title": "1  First probability ideas and first steps in R",
    "section": "1.5 Project 1: Craps: A casion dice game.",
    "text": "1.5 Project 1: Craps: A casion dice game.\nThe first project is about one of the very few dice games offered at a Casino: Craps.6\n6  This will be the only project in this course where we do not go into a direct financial application. Before we can do so, we need to build still a bit more knowledge of probability and skills in R.In Craps people throw a pair of dice and bet on outcomes of these throws. In this project we practice our new knowledge by implementing the dice throws of craps and the automatic summation of points on the computer. We try to find out the probability of the possible outcomes and check the fairness of the dice.\n\nYour first task in this project will be to write a function which allows you to virtually throw a pair of dice and sum up the points shown after the throw.\nSimulate and plot the result of your simulation using qplot() with the binwidth argument set to 1.\nAre these dice fair? Why?\nAssume the dice were unfair in the following sense: Numbers 1,2,3,4 and 5 have a probability of \\(1/8\\) while the 6 has a probability of \\(3/8\\). Study the help page of the samplefunction and find out how you could give these new probability weights to the function. If you redo your simulation analysis with the loaded dice, how does the picture change?\nWrite a script for this random experiment.\nNow look at the random experiment of throwing two dice with the concepts from probability theory: What is the sample space of this experiment. What are the probabilities of the basic outcomes? What is the probability of getting sum 7, what is the probability of getting sum 2 for the case of the fair dice, for the case of the unfair dice?\nImagine now that you are at the casino which uses fair dice and you can spend 150 Euro for chips. Since you have figured out that 7 is the most likely outcome you would like to buy bets on 7. The casino offers you a bet for 15 cent. When you win you get 1 Euro for the bet, when you loose you get nothing. Every bet costs 15 cents, so you can make 1000 bets in total on 7 from your budget of 150. Is this a good or a bad deal for you? Try to think about this problem in terms of a simulation.\n\n\n\n\n\nDiaconis, Persi, and Brian Skyrms. 2019. 10 Great Ideas about Chance. Princeton University Press.\n\n\nHealy, Kirean. 2019. Data Visualization: A Practical Introduction. Princeton University Press.\n\n\nNarayanan, Arvind, Joseph Bonneau, Edward Felten, Andrew Miller, and Steven Goldfeder. 2016. Bitcoin and Cryptocurrency Technologies: A Comprehensive Introduction. Princeton University Press.\n\n\nWickham, Hadley, and Garrett Grolemund. 2017. R for Data Science. O’Reilly. https://r4ds.had.co.nz/.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>First probability ideas and first steps in R</span>"
    ]
  },
  {
    "objectID": "01-lecture1.html#tossing-a-coin",
    "href": "01-lecture1.html#tossing-a-coin",
    "title": "1  First probability ideas and first steps in R",
    "section": "",
    "text": "1.1.1 Random experiments, sample space, events\nIn the theory of probability a process leading to an uncertain outcome is called a random experiment. The example of tossing a coin helps us to give a precise meaning to the notion of an uncertain outcome. While we can imagine in principle that the coin lands on its rim and this is one outcome, we agree on the outset that we are going to consider the (practically relevant cases) that it will land on one of the faces.\nThe collection of all possible outcomes of a practical or conceptual random experiment is called in probability theory a sample space. While the sample space of tossing a coin is an idealization it is exactly this idealization which simplifies the theory without affecting its applicability. The basic outcomes in the random experiment of tossing a coin are that the die lands such that the upward showing face shows Heads or Tails. Let us encode this outcome by 1 for “Heads” and 0 for “Tails”. In the theory the collection of basic outcomes is denoted as a set. Thus the sample space of tossing a coin is given as the set \\({\\cal S} = \\{1,0\\}\\).\nThe sample space \\({\\cal S}\\) is the set of all basic outcomes, which are in our case only two: 1 or 0.\nIn more complex random experiments there will usually be more than two outcomes. Subsets of the sample space containing more than one basic outcome are called events in the theory of probability.\n\n\n\n\n\n\nNow you try\n\n\n\nConsider another random experiment from games of chance: Throwing a six sided die. What are the basic outcomes in this random experiment? What is the sample space in this case? How would you describe the event that the outcome of the die shows an off number in terms of a subset of the sample space?\n\n\n\n\n1.1.2 The role and nature of idealizations in applications\nIdealizations of the kind we discussed for the toss of a coin are standard in probability and we will encounter them again and again. For example the movement of a stock price is often though of as a conceptual random experiment. When we try to agree on what is the appropriate sample space of this experiment, we can say that the price can not fall below 0 but it is hard to agree on what will be the highest possible price. In the probabilistic treatment of stock prices, which we will discuss later in our course, it is for instance common to assume that the sample space of this random experiment is the entire interval of non-negative real numbers \\({\\cal S} = [0, \\infty)\\).\nMany of us would hesitate to claim that the price might rise without bound. Yet many models in applied Finance are based on such an assumption. The models allow arbitrary price hikes but with arbitrary small probability as the price gets higher and higher. Practically it does not make sense to believe that a security price can become arbitrarily high. The use of arbitrarily small probabilities in a financial model might seem absurd but it does no practical harm and makes the model simple and convenient to use. Moreover, if we seriously introduced an upper bound on a security price at \\(x\\) it would be also awkward to assume that it is impossible that it could be just a cent higher, an assumption equally unappealing than assuming it can get in principle arbitrarily high.\n\n\n1.1.3 Classical Probability: Measuring uncertainty\nProbability is a measure of how likely an event of an experiment is. But how could we measure chance? Here is the first big idea of probability theory and how the originators thought about it.1 How do you measure anything? If you think of length, for example, you take an arbitrary standard you agree on and then count. The originators of probability theory pursued the same idea with chance: To measure probability you choose equally probable cases and then count.\n1 In this discussion I use chapter 1 in Diaconis and Skyrms (2019)The probability of an event \\(A\\) according to the originators of the theory of probability is then \\[\\begin{equation}\nP(A) = \\frac{\\text{Number of cases where $A$ occurs}}{\\text{Total number of cases}}\n\\end{equation}\\]\nThus, if we want to know the probability of the coin ending up Heads, we have to compute according to this notion \\(1/2\\), since the total number of cases is 2 (Heads or Tails).\n\n\n\n\n\n\nNow you try\n\n\n\nConsider another random experiment of throwing a six sided die: According to the probability notion explained above what would be the chance that the die lands on on a face such that an even number is shown?.\n\n\nNote that this classical notion of probability has a few interesting consequences, which we will discuss in more detail later but which already now naturally flow from this basic idea of measuring chance.\n\nProbability is never negative.\nIf an event \\(A\\) occurs in all cases \\(P(A)=1\\).\nIf \\(A\\) and \\(B\\) never occur in the same case, then \\(P(A \\,\\text{or}\\, B) = P(A) + P(B)\\).\n\nIn particular then the probability that an event does not occur is 1 less the probability that it occurs: \\(P(\\text{not}\\, A) = 1 - P(A)\\).\nNow let me briefly interrupt here to show you how you can make use of a large language model, using ChatGPT as a use case to support learning new concepts such as we have just introduced them here.\nWe have discussed new two classical and famous random experiments you will probably find in every textbook on probability. Assume you would like to deepen your understanding of these concepts and also consider more complex examples in particular from Finance. This is something the LLM is very good at. You could - for instance - ask ChatGPT at the prompt something like shown in ?fig-Promptgpt :\n\n\n\n\n\nFigure 2: The ChatGPT prompt\n\n\n\n\nHere is an answer I would get for this prompt:\n\n\n\n\n\n\nAnswer by ChatGPT40\n\n\n\nHere are three detailed examples from finance to illustrate the concepts of a random experiment, sample space, basic outcomes, and events:\n\nExample 1: Daily Price Movement of a Stock\nRandom Experiment: Observe the daily price movement of a particular stock (e.g., Apple Inc.) at the close of the trading day.\n\nSample Space ((S)): The set of all possible outcomes of the price movement. For simplicity, we can represent the sample space as: [ S = {} ]\nBasic Outcomes:\n\n“Price increases” (e.g., the stock closes higher than it opened).\n“Price decreases” (e.g., the stock closes lower than it opened).\n“No change” (e.g., the stock closes at the same price it opened).\n\nEvents:\n\nEvent (A): “The stock price increases.” ({price increase})\nEvent (B): “The stock price either increases or remains unchanged.” ({price increase, no change})\n\n\n\nExample 2: Credit Card Default Risk\nRandom Experiment: Assess whether a randomly selected credit card holder defaults on their monthly payment.\n\nSample Space ((S)): [ S = {} ]\nBasic Outcomes:\n\n“Default” (e.g., the cardholder fails to make the minimum payment).\n“No default” (e.g., the cardholder pays at least the minimum required).\n\nEvents:\n\nEvent (A): “The cardholder defaults.” ({default})\nEvent (B): “The cardholder does not default.” ({no default})\nEvent (C): “Default occurs for a customer from a specific demographic (e.g., under 30 years old).” This is a subset of the sample space but is conditioned on additional information.\n\n\n\nExample 3: Bond Ratings Transition\nRandom Experiment: Observe the change in the credit rating of a corporate bond over a year.\n\nSample Space ((S)): The set of possible credit rating transitions. For example, using a simple rating scale: [ S = {, , , , , , , } ]\nOver a year, the bond can transition from its initial rating to any of these, or stay the same.\nBasic Outcomes:\n\n“AAA to AAA” (no change in the highest credit quality).\n“BBB to BB” (downgrade).\n“A to default” (significant deterioration).\n\nEvents:\n\nEvent (A): “The bond is downgraded by one or more notches.” (Any outcome where the final rating is lower than the initial rating, e.g., {AAA to AA, A to BB}).\nEvent (B): “The bond defaults.” ({default}).\nEvent (C): “The bond remains investment-grade.” (All transitions where the final rating is AAA, AA, A, or BBB).\n\n\n\nThese examples show how the concepts apply to finance, helping to bridge the theoretical framework of probability with practical applications in the field. Would you like to dive deeper into any of these examples or extend them to computations like probabilities of events?\n\n\nLet us interrupt here our discussion of probability for a moment and ask how we can make good on our promise to make these ideas tangible, so we can play with them.\nFor this we will need the computer. Since we will talk to the computer in R, it is now the right time to look at the die rolling example from the perspective of R and dive into some of its basic concepts.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>First probability ideas and first steps in R</span>"
    ]
  },
  {
    "objectID": "01-lecture1.html#tossing-coin-on-computer",
    "href": "01-lecture1.html#tossing-coin-on-computer",
    "title": "1  First probability ideas and first steps in R",
    "section": "1.2 Tossing a coin on the computer: First steps in R",
    "text": "1.2 Tossing a coin on the computer: First steps in R\n\n1.2.1 The R User Interface\nBefore we can ask our tool to do anything for us, we need to know how to talk to it. In our case RStudio allows us to talk to our computer. It works like any other application. When you launch RStudio on your computer, in figure @ref(fig:rstudio-start-screen) you see a screen looking like this:\n\n\n\n\n\nThe RStudio startup screen\n\n\n\n\nIn this picture you see a screenshot of my RStudio screen. Interacting with the app is easy. You type commands via your keyboard at the prompt, which is the &gt; symbol. You find this symbol in the RStudio pane called Console. You can see it in the left pane in the screenshot. You send the command to the computer by pressing enter. After you have pressed enter, RStudio sends the command to R and displays the result of your command with a new prompt to enter new commands, like this:\n\n1+1\n\n[1] 2\n\n\nLet me pause to explain what you see here in this code example. First you see a light-gray box containing the command 1+1. This is an instance of a so called code chunk. Moving the cursor to the right upper corner of the chunk, will display a copy icon and you can click this icon to copy the code to the computer’s clipboard and then paste it at the prompt of your console (or for that matter anywhere else) and run it in R studio, if you wish. In the code-chunk the R-prompt &gt; is not displayed. This symbol of the prompt is only shown in the Console itself.\nWhen the code is executed, you see the result in the second light-gray box, just below the first one. It starts with a double hash ##, indicating that it shows an output of running the above code chunk and then displays the output as it would appear in the command window [1] 2.\nThe [1] means that the line begins with the first value of your result. For example, if you enter the command 20:60 at the prompt of your console which means in the R language, “list all the integers from 20 to 60” and press enter you get:\n\n20:60\n\n [1] 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44\n[26] 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60\n\n\nmeaning that 20 is the first value displayed in your result. Then there is a line break because not all values can be displayed on the same line and R tells you that 45 is the 26-th value of the result.\nThe colon operator : is a very useful function in R which we will need often. It allows us to create sequences of every integer between two given integers.\nR needs a complete command to be able to execute it, when the return key is pressed. Lets see what happens, if a command is incomplete, like for instance &gt; 5*.\nIn this case R will show the expression followed by a + instead of showing a new prompt. This means that the expression is incomplete. It expects more input. If we complete the expression, say like\n&gt; 5*\n+ 4\nthe expression can be evaluated and a new prompt is shown in the console.\nIf you type a command that R does not understand, you will be returned an error message. Don’t worry if you see an error message. It just is a way the computer tells you that he does not understand what you want him to do.\nFor instance, if you type 5%3 you will get an error message like this\n&gt; 5%3\nError: unexpected input in \"5%3\"\n&gt;\nSometimes it is obvious why a mistake occurred. In this case, that R just does not know what to do with the symbol %. It has no meaning in this context. Sometimes it is not so obvious what the error message actually means and what you might do about it.\nA useful strategy in this case is to type the error message into a search engine and see what you can find. The chance is very high that others encountered the same problem before you and got helpful advice how to fix it from other users on the internet. One site, we find particularly helpful for all kinds of questions related to R and R programming is https://stackoverflow.com/. Try it at the next opportunity.\nNow with this basic knowledge, we can already make the first step to create a die on the computer using R. If you think of a physical die, the essential thing that matters are the points on its six sides. If you throw the die it will usually land on one of these sides and the upward showing side of the die shows the number of points. The colon operator : gives us a way to create a group of numbers from 1 to 6. R gives us the result as a one dimensional set of numbers.\n\n1:6\n\n[1] 1 2 3 4 5 6\n\n\nLets use these first steps in R to recap the probability concepts we have learned using this example of the six sided die: A basic outcome of rolling a six-sided die is for example 6 if the upper side after rolling the die happens to be the side with 6 points. The sample space of the experiment of rolling a six-sided die is the set \\({\\cal S} = \\{1,2,3,4,5,6\\}\\). In probability theory we often use the symbol \\({\\cal S}\\) or \\(S\\) for sample space. In many probability texts the sample space is also often denoted by the symbol \\(\\Omega\\) the Greek letter for (big) Omega. A random experiment in this example is the rolling of the die. The outcome is uncertain but once the die is rolled the outcome can be determined precisely. The event that the outcome is a display of 10 points is the empty set \\(A = \\emptyset\\). The symbol \\(\\emptyset\\) comes from set theory and means the set containing no elements. This event can contain no elements because we can not get a score of 10 by rolling a six sided die.\n\n\n1.2.2 Objects\nYou can save data in R by storing them in objects. An object is a name, you can choose yourself to store data. For example, if you choose to store the value 6 in an object called point_six, you would type:\n\npoint_six &lt;- 6\n\nat the prompt. R will the store the value 6 in the object called point_six, which you can use to refer to the value. If you type the name of your object at the prompt, R will display the value you have assigned. A useful key combination for typing the assignment operator &lt;- is to use the key combination ALT _. At the R prompt R will automatically print an assignment operator.\nNow if you type the name of the object and press enter, R will display the value or values stored in it, like this:\n\npoint_six\n\n[1] 6\n\n\nNow you can use the name of the object to refer to its value. For instance, you could divide point_sixby 2and get a meaningful result\n\npoint_six/2\n\n[1] 3\n\n\nNow to make our die more tangible and useful, let us store it in an R object by typing the following command at the prompt. This command creates an object with name die and assigns the vector 1,2,3,4,5, 6 to it.\n\ndie &lt;- 1:6\n\n\n\n\n\n\nThe RStudio Environment pane keeps track of the objects you have created\n\n\n\n\nYou can now see in the right upper Environment pane in figure @ref(fig:rstudio-screen-with-command) that R shows you that there is an object with the name die that it consists of integers 1,2,3,4,5. As you create more objects they will be stored in the Environment pane and are ready for your reference, unless you delete them. You can remove or delete an object by typing rm(object) or by assigning the value die &lt;- NULL which would also remove the object from your environment or workspace.\nYou can name your objects almost anything with a few exceptions. An object name must not start with a number. There are some special symbols which can also not be used in object names, like ^, !, $, @, +, -, /, *. Note that R is case sensitive and distinguishes small and big letters. If you assign a new value for an object you have already created, R will overwrite the object without warning.\nYou can see which objects are currently created and available for you in the Environment pane of your session of by typing ls(). The UNIX users among you will recognize this command from the unix shell, where it displays the files in a directory.\nBefore we learn how we can actually roll our die and perform a random experiment with it, let us briefly use the opportunity to explain a few things about how R does computations. We have already explained that we can use the object name to refer to the value. So for instance if we type\n\ndie*die\n\n[1]  1  4  9 16 25 36\n\n\nThis might irritate some of you because we have called the object a vector. In linear algebra multiplication of vectors is only allowed if there is an inner product. What happens here, if we use * the multiplication operator is that R does an element-wise multiplication of the six numbers of our die. Of course R allows to take an inner product as well, but this needs a different operator. To compute an inner product, we would type\n\ndie %*% die\n\n     [,1]\n[1,]   91\n\n\nNow R displays the result as a vectors with one row and one column, which is denoted in the output by [ , 1] for the column and [1, ] for the row. We will learn later more about the use and the meaning of this notation in R.\nThe element wise execution R usually uses also means that when you, for example type\n\ndie - 1\n\n[1] 0 1 2 3 4 5\n\n\nR would subtract 1 from every component in the vector die.\nAnother specific behavior of R, you need to know about is called recycling. If you give R two vectors of different length in an operation, R will repeat the shorter vector as long as it is of equal length with the longer one. For example, if you have: ::: {.cell}\ndie + 1:2\n\n[1] 2 4 4 6 6 8\n\n:::\nyou see that R adds 1 to 1 and 2 to 2 and then starts over again by adding 1 to 3 and 2 to 4 and then starts over once again by adding 1 to 5 and 2 to 6. If the longer vectors is not a multiple of the shorter one, R recycles but the cuts off. It will give you a warning though. ::: {.cell}\ndie + 1:4\n\nWarning in die + 1:4: longer object length is not a multiple of shorter object\nlength\n\n\n[1] 2 4 6 8 6 8\n\n:::\nWhile this might seem awkward to some of you, we will see that for data manipulation element-wise execution is often extremely useful. It allows to manipulate groups of values in a systematic yet easy way.\n\n\n1.2.3 Functions\nR contains many functions which we can use to manipulate data and compute things. The syntax for using a function is very simple: You type the function name and put the value of the function argument in parentheses. Here we use for illustrations the function of the square root sqrt(): ::: {.cell}\nsqrt(4)\n\n[1] 2\n\n::: or rounding a number: ::: {.cell}\nround(3.1415)\n\n[1] 3\n\n::: The data you write in the parentheses are called the function arguments. Arguments can be all sorts of things: raw data, R objects, results from other functions.\nIf functions are nested, R evaluates the innermost function first and then goes on to the outer functions. To see examples of all these instances you can take ::: {.cell}\nmean(1:6)\n\n[1] 3.5\n\nmean(die)\n\n[1] 3.5\n\nround(mean(die))\n\n[1] 4\n\n::: for example.\nFor simulating random experiments, R has the very useful function sample(). With this function we can roll our die on the computer and conduct actual random experiments.\nThe function takes as arguments a vector names x and a number named size. sample will return size elements randomly chosen from the vector x. Lets say: ::: {.cell}\nsample(x = 1:4, size = 2)\n\n[1] 1 2\n\n:::\nIn this case sample has chosen 4,1 from the vector x = (1,2,3,4) at random.\nIf we want to roll the die in our computer we can thus pass the die as an argument to sample and use the number 1 for the size argument. Lets do a few rolls with our die ::: {.cell}\nsample(x = die, size = 1)\n\n[1] 3\n\nsample(x = die, size = 1)\n\n[1] 5\n\nsample(x = die, size = 1)\n\n[1] 3\n\nsample(x = die, size = 1)\n\n[1] 4\n\n::: These are the random outcomes of our consecutive rolls. It is as if we had thrown an actual die but in this case we have done the same thing on the computer. Isn’t it cool that this is possible at all? The sample() function will remain our good friend throughout this course.\nR functions can have many arguments, but they need to be separated by a comma.\nEvery argument in every function has a name. We specify which data are assigned to the arguments by setting a mathematical equal sign = between the name and the data. Names help us to avoid passing the wrong data and thereby mixing up things or committing errors. But using names is not necessary. If we just wrote ::: {.cell}\nsample(die,1)\n\n[1] 6\n\n::: R would also know what to do. It is not always clear which names to use for a function. If you are not sure, you can use the function args() to look it up. Here we take the function roundas one example. ::: {.cell}\nargs(round)\n\nfunction (x, digits = 0, ...) \nNULL\n\n::: Note that the digits argument in the round function is already set to 0. Frequently R functions come with optional arguments. These arguments are optional because the come with a default value, which is 0 in case of the round function.\nWe recommend that you write out argument names as a rule. It gives clearer code and avoids errors. If you don’t write argument names, R matches your values to the arguments of the function by order.\n\n\n1.2.4 Writing your own functions\nNow we are ready to write our own function to roll the die in our computer. Each function in R has the same elements: A name, a function body of code and a set of arguments. To write your own function, you have to write up all of these parts and save them in an R object. The syntax is:\nmy_function &lt;- function() {}\n\nThe name here is my_function, next comes the expression function() which needs to be assigned. The names of the function arguments have to be written between the parentheses. Then we have to write the actual code within the braces {}.\nTo do this for the die, lets write a function named roll_die. ::: {.cell}\nroll_die &lt;- function(){die &lt;- 1:6 \n                         sample(die, size = 1)}\n:::\nNow we can roll our die for a few times to show how the function works ::: {.cell}\nroll_die()\n\n[1] 4\n\nroll_die()\n\n[1] 6\n\nroll_die()\n\n[1] 3\n\nroll_die()\n\n[1] 4\n\nroll_die()\n\n[1] 4\n\n::: Note that in our function roll_die() has no arguments, just the function body. This is perfectly legitimate in R. It is important that when we call the function we have to call it with the parenthesis like roll_die(). If we only call the name roll_die, R will display the code in the function body.\nA final remark in the sample function is in place here. If we look at the arguments of sample using the args function we see ::: {.cell}\nargs(sample)\n\nfunction (x, size, replace = FALSE, prob = NULL) \nNULL\n\n::: Lets do not discuss all the details of this output but concentrate for a moment on the replace argument. What does this mean?\nAs we saw previously we can use the sample function to model the rolling of our die. If we set the size argument to 1 we get the roll of one die. If we set the size argument to n, we would simulate the rolling of n dies. But now the replace argument becomes crucial. As we can see in the output of the args function replace has a default value FALSE. This is a logical argument. It tells R, for example, that if we set size = 2, meaning that two dice are rolled, if the first dice shows, say a value of 3, the second die cannot show 3 as well.\nThis is clearly not what we have in mind when we model the rolling of 2 dice. It should be possible that both dies show the same value. To enable this behavior of the sample function, we have to change the default value of the replace argument to TRUE. Then R chooses a random draw from all of the six possible values for all dice rolled.\nCongratulations ! You have written your first R function for conducting a simple random experiment. Let me remind you once again: Think of the parentheses as a trigger that tells R to run the function. If you omit the trigger R just prints the body of the function. When you run a function, all the code in the function body is executed and R returns the result of the last line of code. If the last line of code does not return a value neither will R.\n\n\n1.2.5 Arguments\nImagine we remove the first line of code in our function body and changed the name die in the sample function to “ball”. ::: {.cell}\nroll_die2 &lt;- function(){sample(ball, size = 1)}\n::: If we call the function now, we will get an error. The function call roll_die2() will result in the error message Error in sample(ball, size = 1) : object 'ball' not found (try it!)\nWe could supply ball when we call roll_die2 if we make ball an argument of the function. Lets do this: ::: {.cell}\nroll_die2 &lt;- function(ball){sample(ball, size = 1)}\n::: Now the function will work as long as we supply ball when we call the function. ::: {.cell}\nroll_die2(ball = 1:6)\n\n[1] 4\n\n::: Note that we still get an error, if we forget to supply ball argument. This could be avoided if we give the function a default argument ::: {.cell}\nroll_die2 &lt;- function(ball= 1:6){sample(ball, size = 1)}\n::: Now if we type: ::: {.cell}\nroll_die2()\n\n[1] 2\n\n::: everything works, just as intended.\n\n\n1.2.6 Scripts\nSo far we have worked by interacting with the console. But what if you want to edit your functions? It would be much easier, if you could use a draft of your code and work form there. This can be done by using a script.\nYou create a script by going to File &gt; New File &gt; R script in the menu bar of RStudio. Using scripts is the standard way to write code in R. It not only helps you to keep track of your code, save it and edit it later. It also makes your work reproducible. You can edit and proofread your code and share it with others. To save your script go to File &gt; Save As in the menu bar.\n\n\n\n\n\nThe RStudio Script\n\n\n\n\nRStudio has many useful features to help you work with scripts. You can for instance automatically execute a line in a code by using the run button. You can also execute sections of code or the entire script. The entire script is executed by running the Source button. For all these commands there are key short cuts which you will learn as you work more with RStudio and R.\nFrom now on you should write all your R-code for this course in scripts. Make a new folder for the scripts you write and store your R-code there from now on.\n\n\n1.2.7 Using packages and finding Help\nWe have now a function which we can use to simulate the rolling of a die, roll_die(). If the die is fair it should be the case that if we roll the die often, all numbers should occur about equally often. The die should not be weighted in favor of a particular value.\nOne way to learn whether our die is fair are repetition and visualization. These are tools we will need all the time, when working with data and when doing probability. While R has many useful functions, one of the great powers is that R is constantly extended by a huge community of users by providing packages.\nPackages are add on functions, which will not be available when you install R. They need to be installed and loaded before you can use them. Since packages are such a powerful tool in R we need to introduce what they are and how to use them in the beginning.\n\n\n1.2.8 Packages\nThere are many visualization tools in R that come with the basic installation. Since the point we want to make here is about packages, we will use a visualization function which is part of the add on package ggplot2, a very popular package for making all kinds of graphs. ggplot2 is not part of the base-R distribution. It has to be therefore loaded before we can use it.\nThere are many additional functions provided with this package. Indeed you could run a whole course on just that 2 For the point we want to make here we will use just one of them, called qplot(), a shorthand for for quick plot.\n2 A very good starting point is for instance Healy (2019), in case you are interested. Also a good source is the first chapter in Wickham and Grolemund (2017).Since qplot() is a function in the package ggplot2, we first need to install this package. To install a package you need to be connected to the internet. If you have internet connection go to the command line and run at the command line: install.packages(\"ggplot2\").\nR displays what is happening while executing the command. Don’t worry if you don not know what all of these messages exactly mean and don’t panic that they are displayed in red. All packages can be installed like this. You have just to enter the correct name in the function install.packages(). The lower right pane in the RStudio software alternatively provides a tab called Packages. Using this tab, you can also install R packages interactively by clicking the install button on the upper left corner of the Packages tab.\nAfter installation the package is on our hard-drive but it can not yet be used. To use the package it has to be loaded. This is done with the command library. To load the ggplot2 package we type ::: {.cell}\nlibrary(\"ggplot2\")\n::: and hit the return key. Many things could be said about the R package system and you will learn it in more detail as we go along in our course. For the moment the most important thing to remember is that a package needs to be newly loaded whenever you want to use it in a new R session.\nTo check whether our dies is fair, we need to roll it many times. R provides a function, that does this for us. This function is called replicate() and provides an easy way to repeat a command many times. The number of times we want to repeat something is given as an argument to the replicate function.\nNow lets roll our die 100 times and save the result in an object we call rolls: ::: {.cell}\nrolls &lt;- replicate(100, roll_die())\n::: We now use the qplot()function from the ggplot2 library to make a quick visualization, by typing the command qplot(rolls). I include the resulting picture in the following figure ::: {.cell layout-align=“center”} ::: {.cell-output-display}  ::: ::: If you try this and your picture looks a bit different from mine, don’t worry. This is as things should be. I have stored the picture after one particular run of the replicate function and saved it in my figures folder to these lecture notes. Each time you run the replicate function anew a new random outcome is stored which will look not exactly the same as any other or course. This is what randomness does to the outcome of rolling a die.\nIt looks like every value occurred roughly 16 times but there is still quite some variation. For instance, the value 3 seems to occur more than 20 times whereas the value 2 occurs less than 15 times.\nMaybe we have to give it another trial with more replications. With the computer we can do this with a fingertip. Let us roll our die 10000 times and plot the result.\n&gt; rolls2 &lt;- replicate(10000, roll_die())\n&gt; qplot(rolls2m bindwidth = 1)\nNow the picture looks better.\n\n\n\n\n\nFrequencies of 1, 2, 3, 4, 5, 6 after rolling our virtual die 10000 times\n\n\n\n\nWe will learn in our course why the picture get better as we increase the number of rolls of the die. For the moment, let us just state that at least for this case it seems that there is no significant visual evidence that our virtual die is loaded.\n\n\n1.2.9 Getting Help\nWe have now learned a tiny number of R functions and we have written one function ourselves. We have learned how to make use of functions provided by packages.\nIt would be overwhelming to memorize and learn them all. In R, fortunately, every function comes with a detailed documentation and with its own help page. You need to learn how to use this source right from the beginning.\nTo access the help page of a function you type the function name preceded by a question mark at the prompt, like this ::: {.cell}\n?sample\n:::\nThen, after you have pressed the return key, a help page is opened in the right lower pane under the help tab as shown in @ref(fig:helpinr) ::: {.cell layout-align=“center”} ::: {.cell-output-display}  ::: :::\nThis help page has a particular structure that you will find for every other R function no matter whether it is provided by the base installation or by a package. In the upper left corner you see the name of the function (sample) and in curly brackets next to it the term base, which means that this is a function in the R base installation. Then you see a headline about what the function does.\nFrom the top of the page, you then first see the field Description. This is a short description what the function does. Here it says\nDescription\nsample takes a sample of the specified size from the elements of x using either with or without replacement.\nThe next field is Usage. It gives you the function description with the arguments. Here for example\nUsage\nsample(x, size, replace = FALSE, prob = NULL)\n\nsample.int(n, size = n, replace = FALSE, prob = NULL,\n           useHash = (!replace && is.null(prob) && size &lt;= n/2 && n &gt; 1e7))\n           \nThe first line in Usage should by now be familiar. Don’t worry about the second line. The function can obviously do more than we know so far.\nNext comes a list of arguments the function takes and what type of information R expects you to provide, as well as what R will do with this information. Here it says for example\nArguments\nx   \neither a vector of one or more elements from which to choose, or a positive integer. See ‘Details.’\n\nn   \na positive number, the number of items to choose from. See ‘Details.’\n\nsize    \na non-negative integer giving the number of items to choose.\n\nreplace \nshould sampling be with replacement?\n\nprob    \na vector of probability weights for obtaining the elements of the vector being sampled.\n\n...\n\nWe omit some information here.\nThen comes a field called Details which gives a more in-depth description of the function. The next field is called Value. It describes what the function returns when you run it. Then we have a reference to related R functions under the field See. Finally there is a field called Examples. This field contains example code that is guaranteed to work. It shows a couple of different cases how you can use the function in practice.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>First probability ideas and first steps in R</span>"
    ]
  }
]