<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.57">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>7&nbsp; Appendix â€“ An Introduction to Probability</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<link href="./06-references.html" rel="prev">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


</head>

<body class="nav-sidebar floating">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./07-appendix.html"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">Appendix</span></a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="Search" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="./">An Introduction to Probability</a> 
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Preface</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./01-lecture1.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">First probability ideas and first steps in R</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./02-lecture2.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Probability: Basic Definitions and Rules</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./03-lecture3.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Conditional Probability</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./04-lecture4.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Random Variables</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./05-lecture5.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Continuous random variables</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./06-references.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">References</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./07-appendix.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">Appendix</span></span></a>
  </div>
</li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#further-reading" id="toc-further-reading" class="nav-link active" data-scroll-target="#further-reading"><span class="header-section-number">7.1</span> Further Reading</a>
  <ul class="collapse">
  <li><a href="#probability-theory-and-mathematics" id="toc-probability-theory-and-mathematics" class="nav-link" data-scroll-target="#probability-theory-and-mathematics"><span class="header-section-number">7.1.1</span> Probability theory and mathematics</a></li>
  <li><a href="#further-studies-of-r" id="toc-further-studies-of-r" class="nav-link" data-scroll-target="#further-studies-of-r"><span class="header-section-number">7.1.2</span> Further studies of R</a></li>
  <li><a href="#probability-philosophy-and-concepts" id="toc-probability-philosophy-and-concepts" class="nav-link" data-scroll-target="#probability-philosophy-and-concepts"><span class="header-section-number">7.1.3</span> Probability, Philosophy and Concepts</a></li>
  <li><a href="#monte-carlo-simulation-and-computing" id="toc-monte-carlo-simulation-and-computing" class="nav-link" data-scroll-target="#monte-carlo-simulation-and-computing"><span class="header-section-number">7.1.4</span> Monte Carlo Simulation and Computing</a></li>
  <li><a href="#finance-and-risk-management" id="toc-finance-and-risk-management" class="nav-link" data-scroll-target="#finance-and-risk-management"><span class="header-section-number">7.1.5</span> Finance and Risk Management</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">Appendix</span></h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="further-reading" class="level2" data-number="7.1">
<h2 data-number="7.1" class="anchored" data-anchor-id="further-reading"><span class="header-section-number">7.1</span> Further Reading</h2>
<p>This is the end of this lecture and these lecture notes which have made an attempt to teach you introductory probability by building probability concepts with R in a finance application context. The field of probability and its applications is huge an rich and only a tiny part of it could be covered in this course. The hope is, of course, that the lecture has been able to teach you some tools and concepts which will enable those of you who found this subject interesting to explore it on your own, using your own interests and the literature on probability as a guide. For those of you who want to do so, let me give you a few pointers to the literature, which might cover for some of you the next steps.</p>
<section id="probability-theory-and-mathematics" class="level3" data-number="7.1.1">
<h3 data-number="7.1.1" class="anchored" data-anchor-id="probability-theory-and-mathematics"><span class="header-section-number">7.1.1</span> Probability theory and mathematics</h3>
<p>I have confessed already in the beginning of this lecture that I think that among the many probability books on the market the book by <span class="citation" data-cites="Feller1968">Feller (<a href="06-references.html#ref-Feller1968" role="doc-biblioref">1968</a>)</span> is still an outstanding master piece in exposition. It is full of passion and enthusiasm for the subject and interesting throughout. Its orientation is clearly mathematical but the confinement to discrete sample spaces allows him to cover much ground with minimal machinery. Reading or studying this books is perhaps even more fun today since you can complement by using the computer to study and think about the many interesting examples contained in it, something you could not do when the book first appeared.</p>
<p>Among the big ideas in probability was the attempt to build a general, axiomatic framework for the field that would establish probability theory firmly as a field of mathematics. The modern mathematical formulation of probability is perhaps nowhere better presented than in <span class="citation" data-cites="Billingsley1995">Billingsley (<a href="06-references.html#ref-Billingsley1995" role="doc-biblioref">1995</a>)</span>. It is a very good source for those of you who have or had some more advanced training in mathematics.</p>
</section>
<section id="further-studies-of-r" class="level3" data-number="7.1.2">
<h3 data-number="7.1.2" class="anchored" data-anchor-id="further-studies-of-r"><span class="header-section-number">7.1.2</span> Further studies of R</h3>
<p>If you are a beginner of R and if you found the language and what it can do useful and interesting I recommend to study the book by <span class="citation" data-cites="Grolemund2014">Grolemund (<a href="06-references.html#ref-Grolemund2014" role="doc-biblioref">2014</a>)</span>. It is a great read and I have relied very much on it for this course. From this book I tried to emulate the idea that R is best taught withing a concrete context instead of teaching the language as such perhaps with a few toy examples and then apply the machinery afterwards. The book is also available online and I recommend the beginners among you very warmly to study it. You can get the book on the internet at https://rstudio-education.github.io/hopr/</p>
<p>More advanced students in the group who want to learn and understand R seriously as a programming language, should at some stage study <span class="citation" data-cites="Wickham2019">Wickham (<a href="06-references.html#ref-Wickham2019" role="doc-biblioref">2019</a>)</span>. This book is also freely available in an online edition at https://adv-r.hadley.nz/.</p>
<p>Finally let me point out to you an excellent guide to the huge number of useful books many of them freely available at the site https://www.bigbookofr.com/ which is a regularly updated list of books about R and applications of R.</p>
</section>
<section id="probability-philosophy-and-concepts" class="level3" data-number="7.1.3">
<h3 data-number="7.1.3" class="anchored" data-anchor-id="probability-philosophy-and-concepts"><span class="header-section-number">7.1.3</span> Probability, Philosophy and Concepts</h3>
<p>For those of you who have an interest in conceptual and foundational discussions and reflections, I would like to point you to four sources in particular. First of all, I think you should at some stage study the outstanding discussion by <span class="citation" data-cites="DiaconisSkyrms2019">Diaconis and Skyrms (<a href="06-references.html#ref-DiaconisSkyrms2019" role="doc-biblioref">2019</a>)</span>. I made several references to it in these lecture notes. It is a truly good read.</p>
<p>For those of you who have the training and the interest in more formal discussions, I would like to recommend the monographs of <span class="citation" data-cites="Gilboa2009">Gilboa (<a href="06-references.html#ref-Gilboa2009" role="doc-biblioref">2009</a>)</span> and <span class="citation" data-cites="Halpern2017">Halpern (<a href="06-references.html#ref-Halpern2017" role="doc-biblioref">2017</a>)</span></p>
<p>An outstanding and very famous book, which is more of a meditation about randomness also with respect to financial markets is <span class="citation" data-cites="Taleb2007">Taleb (<a href="06-references.html#ref-Taleb2007" role="doc-biblioref">2007</a>)</span>. If you had to choose one and only one book in this section, it is perhaps this one.</p>
</section>
<section id="monte-carlo-simulation-and-computing" class="level3" data-number="7.1.4">
<h3 data-number="7.1.4" class="anchored" data-anchor-id="monte-carlo-simulation-and-computing"><span class="header-section-number">7.1.4</span> Monte Carlo Simulation and Computing</h3>
<p>We discussed a lot about simulation in this lecture. If you want to learn about Monte Carlo simulation seriously, you should at some stage study <span class="citation" data-cites="Liu2001">Liu (<a href="06-references.html#ref-Liu2001" role="doc-biblioref">2001</a>)</span>. A standard reference for Monte Carlo Simulation in Finance and Financial Engineering is <span class="citation" data-cites="Glasserman2003">Glasserman (<a href="06-references.html#ref-Glasserman2003" role="doc-biblioref">2003</a>)</span></p>
</section>
<section id="finance-and-risk-management" class="level3" data-number="7.1.5">
<h3 data-number="7.1.5" class="anchored" data-anchor-id="finance-and-risk-management"><span class="header-section-number">7.1.5</span> Finance and Risk Management</h3>
<p>There are many books on Finance, some very technical other verbose and business like. I believe that among the Finance books I know the book by <span class="citation" data-cites="Luenberger2009">Luenberger (<a href="06-references.html#ref-Luenberger2009" role="doc-biblioref">2009</a>)</span> is truly outstanding. A comprehensive overview on the methods and mathematics of risk management in a financial context is <span class="citation" data-cites="McNeilEmbrechtsFrey2015">McNeil, Embrechts, and Frey (<a href="06-references.html#ref-McNeilEmbrechtsFrey2015" role="doc-biblioref">2015</a>)</span></p>
<!-- ## Worked Solutions for Projects -->
<!-- ### Project 1: Proposal for worked solution -->
<!-- ``` -->
<!-- 1. Your first task in this project will be to write a function which allows you  -->
<!-- to virtually throw a pair of dice and sum up the points shown after the throw. -->
<!-- ``` -->
<!-- Here is one possible implementation. Note that there are - of course - other -->
<!-- ways providing the same output. The lines starting with -->
<!-- `#` are comments. You can read them when editing the function script -->
<!-- but R will ignore them when interpreting the function. -->
<!-- ```{r} function to roll two dice and sum their points} -->
<!-- roll <- function(){ -->
<!--   # create a die -->
<!--   die <- 1:6 -->
<!--   # roll the dice by making use of sample. We roll two dice, therefore size has to be equal to 2 -->
<!--   # note that we need to set replace to TRUE because both dice should be able to show all possible -->
<!--   # points -->
<!--   dice <- sample(die, size = 2, replace = TRUE) -->
<!--   # sum up the points of the two dice -->
<!--   sum(dice) -->
<!-- } -->
<!-- ``` -->
<!-- Comment: Note that when you choose to sample twice from the points 1 - 6 using the `sample()`  -->
<!-- function, you need to set the replace argument to `TRUE`. Check the notes or the help for  -->
<!-- sample if you need to look up what this means. If replace is set to `FALSE` - as is the default with sample - then you have a situation where it is impossible that when the first die shows -->
<!-- a particular number, the second dice shows it as well. This is clearly not what we have in mind -->
<!-- if we think of dice throws. Of course we want to allow, for example, that both dice ,may show 6. -->
<!-- ``` -->
<!-- 2. Simulate and plot the result of your simulation using `qplot()` with the `binwidth` -->
<!-- argument set to 1. Use 10000 runs of your function for the simulation. -->
<!-- ``` -->
<!-- ```{r} simulate and plot} -->
<!-- rolls <- replicate(10000, roll()) -->
<!-- # load library ggplot2. Note: you can load ggplot2 only if you have installed the package first: -->
<!-- # This can be done by typing install.packages(ggplot2) at the prompt of the R console or -->
<!-- # use the RStudio menues in the lower right panel. -->
<!-- library(ggplot2) -->
<!-- qplot(rolls, binwidth = 1) -->
<!-- ``` -->
<!-- Comment: Note that `qplot()` is a function contained in an R library in this case ggplot2. This -->
<!-- library is not part of base-R and therefore has to be installed and then  -->
<!-- loaded with the `library()` function. While the package needs to be installed only once, it needs -->
<!-- to be loaded in every new R-session to make it available. There are many other functions, also -->
<!-- functions included in base R, that allow you to make plots. Here we ask for `qplot()` specifically -->
<!-- to familiarize you with the concept of add-pn packages and their use. -->
<!-- ``` -->
<!-- 3. Are these dice fair? Why? -->
<!-- ``` -->
<!-- We answer this question by considering the sample space of this random experiment first. -->
<!-- There are in total $6 \times 6$ pairs, in total 36 ways to sum up points. Each pair -->
<!-- has probability $1/36$ and since the multiple pairs do not occur in the same -->
<!-- event the pair probabilities that lead to a particular sum can be added. The sample space -->
<!-- ${\cal S}$ could be visualized like this: -->
<!-- | Probability         | Outcome              | Possibilities                      | -->
<!-- |:-------------------:|:--------------------:|:-----------------------------------| -->
<!-- |P(sum =  2)  = 1/36  | 2                    | (1,1)                              | -->
<!-- |P(sum =  3)  = 2/36  | 3                    | (1,2),(2,1)                        | -->
<!-- |P(sum =  4)  = 3/36  | 4                    | (1,3),(2,2),(3,1)                  | -->
<!-- |P(sum =  5)  = 4/36  | 5                    | (1,4),(2,3),(3,2),(4,1)            | -->
<!-- |P(sum =  6)  = 5/36  | 6                    | (1,5),(2,4),(3,3),(4,2),(5,1)      | -->
<!-- |P(sum =  7)  = 6/36  | 7                    | (1,6),(2,5),(3,4),(4,3),(5,2),(6,1)|               |P(sum =  8)  = 5/36  | 8                    | (2,6),(3,5),(4,4),(5,3),(6,2)      | -->
<!-- |P(sum =  9)  = 4/36  | 9                    | (3,6),(4,5),(5,4),(6,3)            | -->
<!-- |P(sum = 10)  = 3/36  |10                    | (4,6),(5,5),(6,4)                  | -->
<!-- |P(sum = 11)  = 2/36  |11                    | (5,6),(6,5)                        | -->
<!-- |P(sum = 12)  = 1/36  |12                    | (6,6)                              |  -->
<!-- The frequencies with which the sums occur look very much like the theoretical probabilities -->
<!-- for equally probable pairs. Our dice thus look as if they are fair. Fair here means that -->
<!-- none of the two dice has a bias to land on any face more likely than on another. Of course this -->
<!-- does not mean that all sums occur equally often, because there are for example more combinations -->
<!-- that can result in a sum of 7 than there are combinations that can result in a sum of 12, say. -->
<!-- If the dice are fair the frequencies will be proportional to the theoretical probabilities and -->
<!-- for many independent throws of the dice they should get close to the theoretical probabilities. -->
<!-- ``` -->
<!-- 4. Assume the dice were unfair in the following sense: Numbers 1,2,3,4 and 5 have a  -->
<!-- probability of $1/8$ while the 6 has a probability of $3/8$. Study the help page of -->
<!-- the `sample`function and find out how you could give these new probability weights -->
<!-- to the function. If you redo your simulation analysis with the loaded dice, how does the -->
<!-- picture change? -->
<!-- ``` -->
<!-- ```{r} biased-dice} -->
<!-- roll_biased <- function(){ -->
<!--   # Construct die -->
<!--   die <- 1:6 -->
<!--   # Roll biased or laded die by specifying the probabilities such that there is relatively -->
<!--   # more mass on outcome 6. -->
<!--   dice <- sample(die, size = 2, replace = TRUE, prob = c(1/8, 1/8, 1/8, 1/8, 1/8, 3/8)) -->
<!--   sum(dice) -->
<!-- } -->
<!-- ``` -->
<!-- ```{r} simulate-biased-die} -->
<!-- rolls <- replicate(10000, roll_biased()) -->
<!-- qplot(rolls, binwidth = 1) -->
<!-- ``` -->
<!-- Comment: This example shows that you can determine the probabilities with which the sample -->
<!-- function draws basic outcomes. If you would not know these probabilities but only the plot -->
<!-- you would immediately realize that the dice must be biased because also with many rolls the -->
<!-- relative frequencies are nowhere near where you would expect them if the dice were fair -->
<!-- ``` -->
<!-- 5. Write a script for this random experiment. -->
<!-- ``` -->
<!-- We create a script with `File > new File > R script`and write the code for `roll_biased` into the script. That's it.  -->
<!-- ``` -->
<!-- 6. Now look at the random experiment of throwing two dice with the concepts from -->
<!-- probability theory: What is the sample space of this experiment. What are the  -->
<!-- probabilities of the basic outcomes? What is the probability of getting sum 7, what is -->
<!-- the probability of getting sum 2? -->
<!-- ``` -->
<!-- The sample space is: -->
<!-- ${\cal S} = \{ (1,1), (1,2), (1,3), (1,4), (1,5), (1,6), \\ -->
<!-- (2,6), (3,6), (4,6), (5,6), (6,6), (2,1), (2,2), (2,3), \\ -->
<!-- (2,4), (2,5), (3,5), (4,5), (5,5), (6,5), (3,1), (3,2), \\ -->
<!-- (3,3), (3,4), (4,4), (5,4), (6,4), (4,1), (4,2), (4,3), \\ -->
<!-- (5,3), (6,3), (5,1), (5,2), (6,2), (6,1) \}$ -->
<!-- The probabilities of the basic outcomes are $1/36$.  -->
<!-- The probability of getting the sum 7 is -->
<!-- $6/36$ or $1/6$,  -->
<!-- the probability of getting a 2 is $1/36$. -->
<!-- Comment: I have not specified in the question whether the probabilities  -->
<!-- should be computed for the fair or the -->
<!-- unfair die. I should have perhaps formulated more precisely. -->
<!-- Here I showed the probabilities of the fair dice. The sample space would be the -->
<!-- same for both cases.  -->
<!-- ``` -->
<!-- 7. Imagine now that you are at the casino which uses fair dice and you can spend 150 Euro -->
<!-- for chips. Since you have figured out that 7 is the most -->
<!-- likely outcome you would like to buy bets on 7. The casino -->
<!-- offers you a bet for 15 cent. When you win you get 1 Euro for the -->
<!-- bet, when you loose the Casino gets the 15 cents.  -->
<!-- So you could make 1000 bets in total  -->
<!-- on 7. Is this a good or a bad deal for you? Try to think about -->
<!-- this problem in terms of a simulation. -->
<!-- ``` -->
<!-- Comment: I realized that my formulation of the payoffs is misleading and this created confusion. -->
<!-- This is my fault. What I should have written is: if you win you get 1 and if you loose you get -->
<!-- nothing. Every bet costs 15 cents. This is the situation I had in mind but failed to formulate -->
<!-- clearly.  -->
<!-- With 15 cent per bet and a budget of 150 we can bet on 1000 rolls -->
<!-- of the dice. Theoretically the proportion of outcomes where the sum is -->
<!-- 7 should be 6/36 or 1/6 so you would gain 1 in about 166 cases and 0 otherwise.  -->
<!-- You would pay 150 for 1000 rolls since your chip costs 0.15 per bet. This would -->
<!-- result in a net gain. So theoretically this should be a good deal for you. -->
<!-- If we take a simulation approach we have to keen the following in mind: -->
<!-- Now if you roll the dice 1000 times the proportion of getting will vary from run to run and -->
<!-- sometimes it will show more and at other times less outcomes where the sum is 7, so you do not see -->
<!-- from a simulation of 1 run of 1000 rolls clearly if you make a loss or a gain. If you simulate -->
<!-- many such runs you will get a clearer picture. -->
<!-- Function for 1 run: -->
<!-- ```{r} simulate a craps bet} -->
<!-- craps <- function(n, cost){ -->
<!--   # roll the dice n times. For our particular example this would be n = 1000 and store the -->
<!--   # results, the sums in a vector outcomes. -->
<!--   outcomes <- replicate(n, roll()) -->
<!--   # select the outcomes where the sum is 7 -->
<!--   wins <- (outcomes == 7) -->
<!--   # Since for each win you get 1 you can sum the total wins to get your revenue. Deduct the -->
<!--   # total costs to get your profit -->
<!--   sum(wins) - (cost*n) -->
<!-- } -->
<!-- ``` -->
<!-- One round: -->
<!-- ```{r}} -->
<!-- craps(1000,0.15) -->
<!-- ``` -->
<!-- Here you have a gain. But this could be due to randomness. To see clearer you might want -->
<!-- to do many repetitions for this, say 1000. -->
<!-- ```{r}} -->
<!-- sim <- replicate(1000, craps(1000,0.15)) -->
<!-- ``` -->
<!-- Lets plot the profits for you -->
<!-- ```{r}} -->
<!-- qplot(sim, bins = 10) -->
<!-- ``` -->
<!-- On average you would make a profit under these terms. Can this be true? One way to think about  -->
<!-- it is that in one run of 1000 rolls you should make revenues of about 6/36*1000, because this -->
<!-- is the proportion of cases where you make 1 Euro. Overall this would be 166.6667. Even if -->
<!-- you pay 150 for this you will make a gain. It seems to be a good deal for you. No Casino in the -->
<!-- world will ever offer such terms! -->
<!-- ### Project 2: Proposal for worked solution: -->
<!-- ``` -->
<!-- 1. Go to the EBA website https://www.eba.europa.eu/risk-analysis-and-data/eu-wide-stress-testing -->
<!-- and download the  -->
<!-- file Credit Risk IRB (https://www.eba.europa.eu/assets/st21/full_database/TRA_CRE_IRB.csv). -->
<!-- You can do so by downloading the file, storing it locally and then read it into R or you can -->
<!-- read it directly from the web. -->
<!-- ``` -->
<!-- We download the file directly and store it in an R-object, which we call `eba_data` -->
<!-- ```{r} download-eba} -->
<!-- eba_data <- read.csv("https://www.eba.europa.eu/assets/st21/full_database/TRA_CRE_IRB.csv", stringsAsFactors = FALSE) -->
<!-- ``` -->
<!-- This should result in an R-object `eba_data` (or whatever name you chose to give to the data) with -->
<!-- 528550 records of 15 variables. One way to check this would be the `dim()` function we also -->
<!-- used in the lecture: -->
<!-- ```{r} check-data-dim} -->
<!-- dim(eba_data) -->
<!-- ``` -->
<!-- ``` -->
<!-- 2-(a) Extract all variables names, using the `names()`function. -->
<!-- ``` -->
<!-- We refer to our data object by name `eba_data`. You must choose the name you have selected, of course. -->
<!-- ```{r} extract-names} -->
<!-- names(eba_data) -->
<!-- ``` -->
<!-- ``` -->
<!-- 2-(b) Select all rows where the Scenario variable has value 1. Note -->
<!--        that the symbol you need in the R syntax for equal is `==`, the syntax is therefore  -->
<!--        `Scenario == 1`. You might check out the R-help entry `Comparison` for further details. -->
<!-- ``` -->
<!-- We overwrite our object name `eba_data`at each step. -->
<!-- ```{r} scenario filter} -->
<!-- eba_data <- eba_data[eba_data$Scenario == 1, ] -->
<!-- ``` -->
<!-- Explanation: Since our object name is `eba_data` we subset it by `eba_data[, ]$`. The -->
<!-- first slot addresses rows the second slot addresses columns. We want to say: Take those rows -->
<!-- where the column Scenario takes value 1. The column scenario is `eba_data$Scenario`. The -->
<!-- filter condition is thus written in the row slot. The column slot is left blank because we -->
<!-- want to have records for each variable. Note that without warning R has created here a new -->
<!-- object, with the same name than the old one. But the new `eba_data` has only those rows left, -->
<!-- where the Scenario-Variable is equal to 1. -->
<!-- ``` -->
<!-- 2 -(c) From the resulting data-frame select all rows where the Country variable is not equal to 0.        (hint: The not equal operator in the R syntax is `!=`). If you look into the Metadata-File -->
<!--        you will see that 0 are all the aggregate exposures not broken down by country. Excluding  -->
<!--        these will give us country exposures. -->
<!-- ``` -->
<!-- ```{r} country-select} -->
<!-- eba_data <- eba_data[eba_data$Country != 0, ] -->
<!-- ``` -->
<!-- ``` -->
<!-- 2 -(d) From the resulting data frame select all rows where the Portfolio variable has value 1 or         2.These codes describe the accounting rules under which the exposure values are reported,  -->
<!--        internal rating based (IRB) or standard approach (SA). As a hint you can use R's subset -->
<!--        operator `%in%` here so `Portfolio %in% c(1,2)` written with the approprate subsetting rule -->
<!--        will select all rows where the Porfolio variable has value 1 or 2. -->
<!-- ``` -->
<!-- ```{r} portfolio-select} -->
<!-- eba_data <- eba_data[eba_data$Portfolio %in% c(1,2), ] -->
<!-- ``` -->
<!-- ``` -->
<!-- 2-(e) From the resulting data frame choose all the rows where the Exposure variable is not 0.This -->
<!--        gives again disaggregated numbers. -->
<!-- ``` -->
<!-- ```{r} exposure-select} -->
<!-- eba_data <- eba_data[eba_data$Exposure != 0, ] -->
<!-- ``` -->
<!-- ``` -->
<!-- 2-(f) From the resulting data frame choose all the rows where the Status variable has value 0. -->
<!-- ``` -->
<!-- ```{r} filter-status} -->
<!-- eba_data <- eba_data[eba_data$Status == 0, ] -->
<!-- ``` -->
<!-- ``` -->
<!-- 2-(g) From the resulting data frame choose all the rows where the IFRS9_Stages variable has value        1,2, or 3. -->
<!-- ``` -->
<!-- ```{r} filter IFRS} -->
<!-- eba_data <- eba_data[eba_data$IFRS9_Stages %in% c(1,2,3), ] -->
<!-- ``` -->
<!-- ``` -->
<!-- 2-(h) From the resulting data frame choose all the rows where the CR_guarantees variable is 0 -->
<!-- ``` -->
<!-- ```{r} filter CR_guarantees} -->
<!-- eba_data <- eba_data[eba_data$CR_guarantees == 0, ] -->
<!-- ``` -->
<!-- ``` -->
<!-- 2- (i) From the resulting data frame choose all the rows where the CR_exp_moratoria variable is 0. -->
<!-- ``` -->
<!-- ```{r} filter-smth} -->
<!-- eba_data <- eba_data[eba_data$CR_exp_moratoria == 0, ] -->
<!-- ``` -->
<!-- ``` -->
<!--  2- (j) From the resulting data frame, drop all rows where the Amount variable is 0. -->
<!-- ``` -->
<!-- ```{r} filter-zero-am} -->
<!-- eba_data <- eba_data[eba_data$Amount!= 0, ] -->
<!-- ``` -->
<!-- This results in a new data frame with dimension: -->
<!-- ```{r} dim-new} -->
<!-- dim(eba_data) -->
<!-- ``` -->
<!-- ``` -->
<!-- 3. Check the type of the Amount variable. -->
<!-- ``` -->
<!-- ```{r} check-type-of-Amount} -->
<!-- typeof(eba_data$Amount) -->
<!-- ``` -->
<!-- Explanation: `typeof(eba_data$Amount)` checks the type of the variable and returns the actual -->
<!-- type. We have reported amounts as strings of characters not as numerics in the data so far. -->
<!-- ``` -->
<!-- 4. Transform the Amount variable to type `numeric()` -->
<!-- ``` -->
<!-- ```{r} change-type-of-Amount} -->
<!-- eba_data$Amount <- as.numeric(eba_data$Amount) -->
<!-- ``` -->
<!-- ``` -->
<!-- 5. Check for NA in the Amount variable in the resulting data frame and if you find any, remove them.  -->
<!-- ``` -->
<!-- ```{r} type Amount} -->
<!-- sum(is.na(eba_data$Amount)) -->
<!-- ``` -->
<!-- Explanation: `is.na(eba_data$Amount)` returns a logical vector which is `TRUE` at the components  -->
<!-- where the Amount variable has value `NA`and `FALSE`otherwise. Applying `sum()` to this vector -->
<!-- coerces `TRUE`to 1 and `FALSE`to 0. If 0 there is no `NA` otherwise we have some, in particular we -->
<!-- have 5763 instances of `NA`. This comes from the fact that some components in Amount contained -->
<!-- the character `.` which returns `NA`if `as.numeric()`is applied to it. This seems clear, since -->
<!-- after all `.` is a string which corresponds to no number. -->
<!-- ```{r} remove-na-from-amount} -->
<!-- eba_data <- na.omit(eba_data) -->
<!-- ``` -->
<!-- ``` -->
<!-- 6. Change the Amount variable from the actual unit of Million Euros to the unit of 1 Euro and throw -->
<!-- away data smaller than 1 after this transformation. -->
<!-- ``` -->
<!-- ```{r} change-units-amount} -->
<!-- eba_data$Amount <- eba_data$Amount*10^6 -->
<!-- ``` -->
<!-- Explanation: If an amount is expressed in units of one million, one million Euro appears as 1. If -->
<!-- we multiply by 10^6 this is expressed as 1 000 000. We transform the Amount variable in this way -->
<!-- and overwrite the old variable by the values with the new units. -->
<!-- ```{r} larger-than-0} -->
<!-- eba_data <- eba_data[eba_data$Amount >= 1, ] -->
<!-- ``` -->
<!-- Explanation: We identify the values larger than 1 by logical subsetting of the Amount variable and -->
<!-- select all these values from the data frame by selecting all rows where the Amount variable is -->
<!-- larger than 1.  -->
<!-- ```  -->
<!-- 7. Select the leading digits from the Amount variable, using R's string functions and add a -->
<!-- variable with name LD to your data frame.  -->
<!-- ``` -->
<!-- ```{r} select-leading digit} -->
<!-- eba_data$LD <- as.character(eba_data$Amount) |> -->
<!--    substr(1,1) -->
<!-- ``` -->
<!-- Explanation: We can extract the leading digit from a string of characters `x` by applying -->
<!-- the `substr()` function, with arguments `1,1` to `x`. To operate with this logic on Amount, we have -->
<!-- to transform the type of Amount back to character first. We then use the R-pipe to apply  -->
<!-- substr to this new variables. The syntax is  -->
<!-- equivalent to `substr(as.character(eba_data$Amount),1,1)` -->
<!-- ``` -->
<!-- 8. Compare the empirical frequencies in the data with the theoretical frequencies -->
<!-- from Benford's law. Do the data look ok or suspicious? -->
<!-- ``` -->
<!-- ```{r} compare-data} -->
<!-- comptable <- as.data.frame(table(eba_data$LD)/length(eba_data$LD)) -->
<!-- names(comptable) <- c("Digit", "Freq") -->
<!-- ``` -->
<!-- Explanation: We tabulate the LD data using the R function `table()`. We divide each count by -->
<!-- the number of observations using the `length()`function to get proportions. The output of this -->
<!-- operation is then forced into a data frame and saved in the variable `comptable` we assign the  -->
<!-- names `Digit`and `Freq` to the variables. -->
<!-- ```{r} add-benford-frequencies} -->
<!-- comptable$Freq_Benf <- log10(1 + 1/as.numeric(comptable$Digit)) -->
<!-- ``` -->
<!-- Explanation: We add a new variable to our data frame using the formula for Benfords law for -->
<!-- the distribution of digits $\{1,2,3,4,5,6,7,8,9\}$. Since we do a computation  -->
<!-- with logs and division we have to be careful to change the type of our character numbers which are -->
<!-- expressed as strings to numerical types first. -->
<!-- ```{r} display} -->
<!-- comptable -->
<!-- ``` -->
<!-- The digit distribution matches up very well. So from the perspective of Benford's law about -->
<!-- the distribution of leading digits the EBA exposure data from the one data file we inspected -->
<!-- here look perfectly ok and seem not to be cooked up in any way. Note that this does not mean -->
<!-- that there are no problems in these data. This analysis jsut provides some first order -->
<!-- evidence that the data seem not to be obviously manipulated or forged. -->
<!-- ### Project 3: Worked solution -->
<!-- In this project we stay within the frame and the rules of the investment game  -->
<!-- discussed in the lecture but we investigate the game a bit in more detail.  -->
<!-- 1. Suppose we are in a new round and a red coin is actually used. But you think initially it is -->
<!-- green. Assuming you prior beliefs are  -->
<!--    i)   0.5 (no idea) -->
<!--    ii)  0.9 (likely green),  -->
<!--    iii) 0.99 (very likely green) -->
<!--    iv)  0.999 (almost surely green).  -->
<!-- What will be the estimates of  -->
<!-- the coin value in these different cases? -->
<!-- 2. By how many flips will you get to the an estimate of 0.601 for each given -->
<!-- prior? -->
<!-- 3. Can you visualize the adjustment of the value estimate over the 30 rounds for the different -->
<!-- priors? -->
<!-- 4. How will the estimates of the worth of each flip develop if the green coin is used for each -->
<!-- of the previous priors? -->
<!-- ``` -->
<!-- 1. Suppose we are in a new round and a red coin is actually used. But you think initially it is -->
<!-- green. Assuming you prior beliefs are  -->
<!--    i) 0.5 (no idea) -->
<!--    ii) 0.9 (likely green),  -->
<!--    iii) 0.99 (very likely green) -->
<!--    iv) 0.999 (almost surely green).  -->
<!-- What will be the estimates of  -->
<!-- the coin value in these different cases? -->
<!-- ``` -->
<!-- We start with the game data or the record we had used in our lecture but with different  -->
<!-- priors: -->
<!-- ```{r}} -->
<!-- prior_scenarios <- function(pg){ -->
<!-- game_record <- data.frame(Data = c("T", "T", "T", "T", "H",  -->
<!--                                    "T", "T", "T", "T", "H", "T",  -->
<!--                                    "H", "T", "H", "H", "T", "T",  -->
<!--                                    "H", "T", "T", "T", "T", "H", "T",  -->
<!--                                    "T", "H", "H", "H", "T", "T")) -->
<!-- game_record$Win <- (game_record$Data == "H") -->
<!-- game_record$Sum_Wins <- cumsum(game_record$Win) -->
<!-- game_record$Num_Flips <- 1:30 -->
<!-- game_record$POG <- dbinom(game_record$Sum_Wins, game_record$Num_Flips, 0.7) -->
<!-- game_record$POR <- dbinom(game_record$Sum_Wins, game_record$Num_Flips, 0.3)   -->
<!-- game_record$PG <- rep(pg, 30)   -->
<!-- game_record$PR <- rep((1-pg), 30) -->
<!-- game_record$PO <- game_record$POG*game_record$PG + game_record$POR*game_record$PR -->
<!-- game_record$PGO <- game_record$POG*game_record$PG/game_record$PO -->
<!-- game_record$Value <- game_record$PGO*0.7*2 + (1-game_record$PGO)*0.3*2 -->
<!-- game_record -->
<!-- } -->
<!-- ``` -->
<!-- ```{r}} -->
<!-- scenario_1 <- prior_scenarios(0.5) -->
<!-- scenario_2 <- prior_scenarios(0.9) -->
<!-- scenario_3 <- prior_scenarios(0.99) -->
<!-- scenario_4 <- prior_scenarios(0.999) -->
<!-- ``` -->
<!-- The coin values in the different cases -->
<!-- ```{r}} -->
<!-- estimated_values_per_round <- data.frame(round = scenario_1$Num_Flips,  -->
<!--                                          vs1 = scenario_1$Value, -->
<!--                                          vs2 = scenario_2$Value, -->
<!--                                          vs3 = scenario_3$Value, -->
<!--                                          vs4 = scenario_4$Value) -->
<!-- estimated_values_per_round -->
<!-- ``` -->
<!-- ``` -->
<!-- 2. By how many flips will you get to the correct estimate of 0.6 for each given -->
<!-- prior? -->
<!-- ``` -->
<!-- ```{r}} -->
<!-- sum(estimated_values_per_round$vs1 >= 0.601) -->
<!-- ``` -->
<!-- ```{r}} -->
<!-- sum(estimated_values_per_round$vs2 >= 0.601) -->
<!-- ``` -->
<!-- ```{r}} -->
<!-- sum(estimated_values_per_round$vs3 >= 0.601) -->
<!-- ``` -->
<!-- ```{r}} -->
<!-- sum(estimated_values_per_round$vs4 >= 0.601) -->
<!-- ``` -->
<!-- Comment: The beliefs converge faster, if you are not too overconfident. With strong -->
<!-- overconfidence in your initial belief, there would be no convergence even after 30 rounds. -->
<!-- ``` -->
<!-- 3. Can you visualize the adjustment of the value estimate over the 30 rounds for the different -->
<!-- priors? -->
<!-- ``` -->
<!-- Visualization: -->
<!-- ```{r}} -->
<!-- plot(estimated_values_per_round$round, -->
<!--      estimated_values_per_round$vs1, -->
<!--      type = "l", -->
<!--      col = 2, -->
<!--      ylim = c(0,1.5), -->
<!--      xlim = c(0,40), -->
<!--      xlab = "Rounds", -->
<!--      ylab = "Values") -->
<!-- lines(estimated_values_per_round$round, -->
<!--      estimated_values_per_round$vs2, -->
<!--      type = "l", -->
<!--      col = 3) -->
<!-- lines(estimated_values_per_round$round, -->
<!--      estimated_values_per_round$vs3, -->
<!--      type = "l", -->
<!--      col = 4) -->
<!-- lines(estimated_values_per_round$round, -->
<!--      estimated_values_per_round$vs4, -->
<!--      type = "l", -->
<!--      col = 5) -->
<!-- lines(estimated_values_per_round$round, -->
<!--       rep(0.6, 30), -->
<!--       type = "l", -->
<!--       col = 6) -->
<!-- legend("topright",                            -->
<!--        c("pg 0.5", "pg 0.9", "pg 0.99", "pg 0.999", "true-value"), -->
<!--        lty = 1, -->
<!--        col = 2:6) -->
<!-- ``` -->
<!-- Comment: You see the dangers of overconfidence. The more confident you are, the longer it  -->
<!-- takes you to converge to the actual true value of 0.6 in this case. -->
<!-- ``` -->
<!-- 4. How will the estimates of the worth of each flip develop if the green coin is used for each -->
<!-- of the previous priors? -->
<!-- ``` -->
<!-- Suppose we flip a green coin 30 times. The sequence we had before came from a red coin. Let's -->
<!-- generate a green coin sequence: -->
<!-- ```{r}} -->
<!-- flip_green <- function(){ -->
<!--    green_coin <- c("H", "T") -->
<!--    sample(green_coin, 1, replace = FALSE, prob = c(0.7, 0.3)) -->
<!-- } -->
<!-- ``` -->
<!-- Flip 30 times: -->
<!-- ```{r}} -->
<!-- draw <- replicate(30, flip_green()) -->
<!-- ``` -->
<!-- Now do the same fuanction as before and give it the name: -->
<!-- `prior_scenarios_2`. -->
<!-- ```{r}} -->
<!-- prior_scenarios_2 <- function(pg){ -->
<!-- game_record <- data.frame(Data = draw) -->
<!-- game_record$Win <- (game_record$Data == "H") -->
<!-- game_record$Sum_Wins <- cumsum(game_record$Win) -->
<!-- game_record$Num_Flips <- 1:30 -->
<!-- game_record$POG <- dbinom(game_record$Sum_Wins, game_record$Num_Flips, 0.7) -->
<!-- game_record$POR <- dbinom(game_record$Sum_Wins, game_record$Num_Flips, 0.3)   -->
<!-- game_record$PG <- rep(pg, 30)   -->
<!-- game_record$PR <- rep((1-pg), 30) -->
<!-- game_record$PO <- game_record$POG*game_record$PG + game_record$POR*game_record$PR -->
<!-- game_record$PGO <- game_record$POG*game_record$PG/game_record$PO -->
<!-- game_record$Value <- game_record$PGO*0.7*2 + (1-game_record$PGO)*0.3*2 -->
<!-- game_record -->
<!-- } -->
<!-- ``` -->
<!-- ```{r}} -->
<!-- scenario_1_green <- prior_scenarios_2(0.5) -->
<!-- scenario_2_green <- prior_scenarios_2(0.9) -->
<!-- scenario_3_green <- prior_scenarios_2(0.99) -->
<!-- scenario_4_green <- prior_scenarios_2(0.999) -->
<!-- ``` -->
<!-- The coin values in the different cases -->
<!-- ```{r}} -->
<!-- estimated_values_per_round_2 <- data.frame(round = scenario_1_green$Num_Flips,  -->
<!--                                          vs1 = scenario_1_green$Value, -->
<!--                                          vs2 = scenario_2_green$Value, -->
<!--                                          vs3 = scenario_3_green$Value, -->
<!--                                          vs4 = scenario_4_green$Value) -->
<!-- estimated_values_per_round_2 -->
<!-- ``` -->
<!-- Visualization: -->
<!-- ```{r}} -->
<!-- plot(estimated_values_per_round_2$round, -->
<!--      estimated_values_per_round_2$vs1, -->
<!--      type = "l", -->
<!--      col = 2, -->
<!--      ylim = c(0,1.5), -->
<!--      xlim = c(0,40), -->
<!--      xlab = "Rounds", -->
<!--      ylab = "Values") -->
<!-- lines(estimated_values_per_round_2$round, -->
<!--      estimated_values_per_round_2$vs2, -->
<!--      type = "l", -->
<!--      col = 3) -->
<!-- lines(estimated_values_per_round_2$round, -->
<!--      estimated_values_per_round_2$vs3, -->
<!--      type = "l", -->
<!--      col = 4) -->
<!-- lines(estimated_values_per_round_2$round, -->
<!--      estimated_values_per_round_2$vs4, -->
<!--      type = "l", -->
<!--      col = 5) -->
<!-- lines(estimated_values_per_round$round, -->
<!--       rep(1.4, 30), -->
<!--       type = "l", -->
<!--       col = 6) -->
<!-- legend("topright",                            -->
<!--        c("pg 0.5", "pg 0.9", "pg 0.99", "pg 0.999", "true-value"), -->
<!--        lty = 1, -->
<!--        col = 2:6) -->
<!-- ``` -->


<div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list" style="display: none">
<div id="ref-Billingsley1995" class="csl-entry" role="listitem">
Billingsley, Patrick. 1995. <em>Probability and Measure</em>. Wiley.
</div>
<div id="ref-DiaconisSkyrms2019" class="csl-entry" role="listitem">
Diaconis, Persi, and Brian Skyrms. 2019. <em>10 Great Ideas about Chance</em>. Princeton University Press.
</div>
<div id="ref-Feller1968" class="csl-entry" role="listitem">
Feller, William. 1968. <em>An Introduction to Probability Theory and Its Applications</em>. 3rd ed. Vol. 1. Wiley.
</div>
<div id="ref-Gilboa2009" class="csl-entry" role="listitem">
Gilboa, Ithak. 2009. <em>Theory of Decision Under Uncertainty</em>. Cambridge University Press.
</div>
<div id="ref-Glasserman2003" class="csl-entry" role="listitem">
Glasserman, Paul. 2003. <em>Monte Carlo Methods in Financial Engineering</em>. Springer.
</div>
<div id="ref-Grolemund2014" class="csl-entry" role="listitem">
Grolemund, Garrett. 2014. <em>Hands on Programming with <span>R</span></em>. Oâ€™Reilly. <a href="https://rstudio-education.github.io/hopr/">https://rstudio-education.github.io/hopr/</a>.
</div>
<div id="ref-Halpern2017" class="csl-entry" role="listitem">
Halpern, Joseph. 2017. <em>Reasoning about Uncertainty</em>. 2nd ed. MIT Press.
</div>
<div id="ref-Liu2001" class="csl-entry" role="listitem">
Liu, Jun S. 2001. <em>Monte Carlo Strategies in Scientific Computing</em>. Springer.
</div>
<div id="ref-Luenberger2009" class="csl-entry" role="listitem">
Luenberger, David. 2009. <em>Investment Science</em>. Oxford University Press.
</div>
<div id="ref-McNeilEmbrechtsFrey2015" class="csl-entry" role="listitem">
McNeil, Alexander, Paul Embrechts, and Rudiger Frey. 2015. <em>Quantitative Risk Management</em>. Princeton University Press.
</div>
<div id="ref-Taleb2007" class="csl-entry" role="listitem">
Taleb, Nassim Nicolas. 2007. <em>Fooled by Randomenss</em>. Penguin.
</div>
<div id="ref-Wickham2019" class="csl-entry" role="listitem">
Wickham, Hadley. 2019. <em>Advanced r</em>. 2nd ed. Taylor; Francis.
</div>
</div>
</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "î§‹";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="./06-references.html" class="pagination-link" aria-label="References">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">References</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
  </div>
</nav>
</div> <!-- /content -->




</body></html>